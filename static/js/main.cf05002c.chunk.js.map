{"version":3,"sources":["components/SimpleTypescriptEditor.jsx","components/typings/index.js","components/typings/models.js","components/typings/ramda.js","components/typings/lambda.js","components/AdvancedTypescriptEditor.jsx","App.jsx","serviceWorker.js","index.jsx"],"names":["code","SimpleTypescriptEditor","_Component","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","inherits","createClass","key","value","newValue","e","react_default","a","createElement","lib_default","width","height","language","theme","defaultValue","onChange","Component","files","models/index.d.ts","ramda/index.d.ts","lambda/index.d.ts","AdvancedTypescriptEditor","monaco","fileName","languages","typescript","typescriptDefaults","setDiagnosticsOptions","noSemanticValidation","noSyntaxValidation","setCompilerOptions","target","ScriptTarget","ES6","allowNonTsExtensions","fakePath","concat","addExtraLib","editor","focus","options","selectOnLineNumbers","model","getModel","Uri","parse","createModel","editorWillMount","editorDidMount","App","style","padding","id","SimpleTypescriptEditor_SimpleTypescriptEditor","AdvancedTypescriptEditor_AdvancedTypescriptEditor","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"2SAGMA,EAAI,4XAoBGC,EAAb,SAAAC,GAGI,SAAAD,EAAYE,GAAM,IAAAC,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAAN,IACdG,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAAJ,GAAAS,KAAAH,KAAMJ,KACDQ,MAAQ,CACTX,QAHUI,EAHtB,OAAAC,OAAAO,EAAA,EAAAP,CAAAJ,EAAAC,GAAAG,OAAAQ,EAAA,EAAAR,CAAAJ,EAAA,EAAAa,IAAA,WAAAC,MAAA,SAUaC,EAAUC,MAVvB,CAAAH,IAAA,SAAAC,MAAA,WAeQ,OACIG,EAAAC,EAAAC,cAACC,EAAAF,EAAD,CACIG,MAAM,MACNC,OAAO,MACPC,SAAS,aACTC,MAAM,UACNC,aAAa,GACbX,MAAOR,KAAKI,MAAMX,KAClB2B,SAAUpB,KAAKoB,eAvB/B1B,EAAA,CAA4C2B,qBCnB/BC,EAAQ,CACjBC,oBCLgB,2KDMhBC,mBENgB,kn/HFOhBC,oBGPgB,6HCOdhC,EAAI,w5BAoDGiC,EAAb,SAAA/B,GAGI,SAAA+B,EAAY9B,GAAM,IAAAC,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAA0B,IACd7B,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAA4B,GAAAvB,KAAAH,KAAMJ,KACDQ,MAAQ,CACTX,QAHUI,EAHtB,OAAAC,OAAAO,EAAA,EAAAP,CAAA4B,EAAA/B,GAAAG,OAAAQ,EAAA,EAAAR,CAAA4B,EAAA,EAAAnB,IAAA,WAAAC,MAAA,SAUaC,EAAUC,MAVvB,CAAAH,IAAA,kBAAAC,MAAA,SAcoBmB,GAcZ,IAAK,IAAMC,KAXXD,EAAOE,UAAUC,WAAWC,mBAAmBC,sBAAsB,CACjEC,sBAAsB,EACtBC,oBAAoB,IAIxBP,EAAOE,UAAUC,WAAWC,mBAAmBI,mBAAmB,CAC9DC,OAAQT,EAAOE,UAAUC,WAAWO,aAAaC,IACjDC,sBAAsB,IAGHjB,EAAO,CAC1B,IAAMkB,EAAQ,+BAAAC,OAAkCb,GAEhDD,EAAOE,UAAUC,WAAWC,mBAAmBW,YAC3CpB,EAAMM,GACNY,MAjChB,CAAAjC,IAAA,iBAAAC,MAAA,SA0CmBmC,EAAQhB,GACnBgB,EAAOC,UA3Cf,CAAArC,IAAA,SAAAC,MAAA,WA+CQ,IAAMqC,EAAU,CACZC,qBAAqB,EACrBC,MAAOpB,SAAcqB,SAASC,MAAIC,MAAM,sBAEpCvB,SAAcwB,YAAY1D,EAAM,aAAckC,MAAWuB,MAAM,sBAEvE,OACIvC,EAAAC,EAAAC,cAACC,EAAAF,EAAD,CACIG,MAAM,MACNC,OAAO,MACPC,SAAS,aACTC,MAAM,UACNC,aAAa,GACbX,MAAOR,KAAKI,MAAMX,KAClB2B,SAAUpB,KAAKoB,SACfgC,gBAAiBpD,KAAKoD,gBACtBC,eAAgBrD,KAAKqD,eACrBR,QAASA,QAhEzBnB,EAAA,CAA8CL,aCjC/BiC,mLAnBP,OACI3C,EAAAC,EAAAC,cAAA,OAAK0C,MAAO,CAACC,QAAS,KAClB7C,EAAAC,EAAAC,cAAA,SAAOE,MAAM,QACTJ,EAAAC,EAAAC,cAAA,UACIF,EAAAC,EAAAC,cAAA,UACIF,EAAAC,EAAAC,cAAA,UAAIF,EAAAC,EAAAC,cAAA,KAAG4C,GAAG,UAAN,6BACJ9C,EAAAC,EAAAC,cAAC6C,EAAD,OAEJ/C,EAAAC,EAAAC,cAAA,UACIF,EAAAC,EAAAC,cAAA,UAAIF,EAAAC,EAAAC,cAAA,KAAG4C,GAAG,YAAN,+BACJ9C,EAAAC,EAAAC,cAAC8C,EAAD,iBAZVtC,aCOEuC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAOvD,EAAAC,EAAAC,cAACsD,EAAD,MAASC,SAASC,eAAe,SD2H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC","file":"static/js/main.cf05002c.chunk.js","sourcesContent":["import React,{Component} from 'react';\nimport MonacoEditor from 'react-monaco-editor'\n\nconst code =\n`\n\n// Define Typescript Interface Employee\ninterface Employee {\n    firstName: String;\n    lastName: String;\n    contractor?: Boolean;\n}\n\n// Use Typescript Interface Employee. \n// This should show you an error on john \n// as required attribute lastName is missing\nconst john:Employee = {\n    firstName:\"John\",\n    // lastName:\"Smith\"\n    // contractor:true\n}\n\n`\nexport class SimpleTypescriptEditor extends Component {\n\n\n    constructor(props){\n        super(props);\n        this.state = {\n            code\n        }\n    }\n\n    onChange(newValue, e) {\n        // console.log('onChange', newValue, e);\n    }\n\n    render() {\n        return (\n            <MonacoEditor\n                width=\"600\"\n                height=\"800\"\n                language=\"typescript\"\n                theme=\"vs-dark\"\n                defaultValue=''\n                value={this.state.code}\n                onChange={this.onChange}\n            />\n        )\n    }\n}","import {content as modelContent} from './models';\nimport {content as lambdaContent} from './lambda';\nimport {content as ramdaContent} from './ramda';\n\nexport const files = {\n    \"models/index.d.ts\": modelContent,\n    \"ramda/index.d.ts\": ramdaContent,\n    \"lambda/index.d.ts\": lambdaContent,\n};\n","export const content =\n`\nexport interface Item {\n   id: String;\n   name: String;\n   value: String;\n}\n\nexport interface Result {\n   id: String;\n   name: String;\n   value: String;\n}\n`","export const content =\n    `  \n// Type definitions for ramda 0.26\n// Project: https://github.com/donnut/typescript-ramda, https://ramdajs.com\n// Definitions by: Erwin Poeze <https://github.com/donnut>\n//                 Tycho Grouwstra <https://github.com/tycho01>\n//                 Matt DeKrey <https://github.com/mdekrey>\n//                 Matt Dziuban <https://github.com/mrdziuban>\n//                 Stephen King <https://github.com/sbking>\n//                 Alejandro Fernandez Haro <https://github.com/afharo>\n//                 Vítor Castro <https://github.com/teves-castro>\n//                 Jordan Quagliatini <https://github.com/1M0reBug>\n//                 Simon Højberg <https://github.com/hojberg>\n//                 Samson Keung <https://github.com/samsonkeung>\n//                 Angelo Ocana <https://github.com/angeloocana>\n//                 Rayner Pupo <https://github.com/raynerd>\n//                 Miika Hänninen <https://github.com/googol>\n//                 Nikita Moshensky <https://github.com/moshensky>\n//                 Ethan Resnick <https://github.com/ethanresnick>\n//                 Jack Leigh <https://github.com/leighman>\n//                 Keagan McClelland <https://github.com/CaptJakk>\n//                 Tomas Szabo <https://github.com/deftomat>\n//                 Bonggyun Lee <https://github.com/deptno>\n//                 Maciek Blim <https://github.com/blimusiek>\n//                 Marcin Biernat <https://github.com/biern>\n//                 Rayhaneh Banyassady <https://github.com/rayhaneh>\n//                 Ryan McCuaig <https://github.com/rgm>\n//                 Drew Wyatt <https://github.com/drewwyatt>\n//                 John Ottenlips <https://github.com/jottenlips>\n//                 Nitesh Phadatare <https://github.com/minitesh>\n//                 Krantisinh Deshmukh <https://github.com/krantisinh>\n//                 Pierre-Antoine Mills <https://github.com/pirix-gh>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 3.2\n\n/// <reference path=\"./es/add.d.ts\" />\n/// <reference path=\"./es/addIndex.d.ts\" />\n/// <reference path=\"./es/adjust.d.ts\" />\n/// <reference path=\"./es/all.d.ts\" />\n/// <reference path=\"./es/allPass.d.ts\" />\n/// <reference path=\"./es/always.d.ts\" />\n/// <reference path=\"./es/and.d.ts\" />\n/// <reference path=\"./es/any.d.ts\" />\n/// <reference path=\"./es/anyPass.d.ts\" />\n/// <reference path=\"./es/ap.d.ts\" />\n/// <reference path=\"./es/aperture.d.ts\" />\n/// <reference path=\"./es/append.d.ts\" />\n/// <reference path=\"./es/apply.d.ts\" />\n/// <reference path=\"./es/applySpec.d.ts\" />\n/// <reference path=\"./es/applyTo.d.ts\" />\n/// <reference path=\"./es/ascend.d.ts\" />\n/// <reference path=\"./es/assoc.d.ts\" />\n/// <reference path=\"./es/assocPath.d.ts\" />\n/// <reference path=\"./es/binary.d.ts\" />\n/// <reference path=\"./es/bind.d.ts\" />\n/// <reference path=\"./es/both.d.ts\" />\n/// <reference path=\"./es/call.d.ts\" />\n/// <reference path=\"./es/chain.d.ts\" />\n/// <reference path=\"./es/clamp.d.ts\" />\n/// <reference path=\"./es/clone.d.ts\" />\n/// <reference path=\"./es/comparator.d.ts\" />\n/// <reference path=\"./es/complement.d.ts\" />\n/// <reference path=\"./es/compose.d.ts\" />\n/// <reference path=\"./es/composeK.d.ts\" />\n/// <reference path=\"./es/composeP.d.ts\" />\n/// <reference path=\"./es/concat.d.ts\" />\n/// <reference path=\"./es/cond.d.ts\" />\n/// <reference path=\"./es/construct.d.ts\" />\n/// <reference path=\"./es/constructN.d.ts\" />\n/// <reference path=\"./es/contains.d.ts\" />\n/// <reference path=\"./es/converge.d.ts\" />\n/// <reference path=\"./es/countBy.d.ts\" />\n/// <reference path=\"./es/curry.d.ts\" />\n/// <reference path=\"./es/curryN.d.ts\" />\n/// <reference path=\"./es/dec.d.ts\" />\n/// <reference path=\"./es/defaultTo.d.ts\" />\n/// <reference path=\"./es/descend.d.ts\" />\n/// <reference path=\"./es/difference.d.ts\" />\n/// <reference path=\"./es/differenceWith.d.ts\" />\n/// <reference path=\"./es/dissoc.d.ts\" />\n/// <reference path=\"./es/dissocPath.d.ts\" />\n/// <reference path=\"./es/divide.d.ts\" />\n/// <reference path=\"./es/drop.d.ts\" />\n/// <reference path=\"./es/dropLast.d.ts\" />\n/// <reference path=\"./es/dropLastWhile.d.ts\" />\n/// <reference path=\"./es/either.d.ts\" />\n/// <reference path=\"./es/empty.d.ts\" />\n/// <reference path=\"./es/endsWith.d.ts\" />\n/// <reference path=\"./es/eqBy.d.ts\" />\n/// <reference path=\"./es/eqProps.d.ts\" />\n/// <reference path=\"./es/equals.d.ts\" />\n/// <reference path=\"./es/evolve.d.ts\" />\n/// <reference path=\"./es/F.d.ts\" />\n/// <reference path=\"./es/filter.d.ts\" />\n/// <reference path=\"./es/find.d.ts\" />\n/// <reference path=\"./es/findIndex.d.ts\" />\n/// <reference path=\"./es/findLast.d.ts\" />\n/// <reference path=\"./es/findLastIndex.d.ts\" />\n/// <reference path=\"./es/flatten.d.ts\" />\n/// <reference path=\"./es/flip.d.ts\" />\n/// <reference path=\"./es/forEach.d.ts\" />\n/// <reference path=\"./es/forEachObjIndexed.d.ts\" />\n/// <reference path=\"./es/fromPairs.d.ts\" />\n/// <reference path=\"./es/groupBy.d.ts\" />\n/// <reference path=\"./es/groupWith.d.ts\" />\n/// <reference path=\"./es/gt.d.ts\" />\n/// <reference path=\"./es/gte.d.ts\" />\n/// <reference path=\"./es/has.d.ts\" />\n/// <reference path=\"./es/hasIn.d.ts\" />\n/// <reference path=\"./es/head.d.ts\" />\n/// <reference path=\"./es/identical.d.ts\" />\n/// <reference path=\"./es/identity.d.ts\" />\n/// <reference path=\"./es/ifElse.d.ts\" />\n/// <reference path=\"./es/inc.d.ts\" />\n/// <reference path=\"./es/indexBy.d.ts\" />\n/// <reference path=\"./es/indexOf.d.ts\" />\n/// <reference path=\"./es/init.d.ts\" />\n/// <reference path=\"./es/innerJoin.d.ts\" />\n/// <reference path=\"./es/insertAll.d.ts\" />\n/// <reference path=\"./es/insert.d.ts\" />\n/// <reference path=\"./es/intersection.d.ts\" />\n/// <reference path=\"./es/intersectionWith.d.ts\" />\n/// <reference path=\"./es/intersperse.d.ts\" />\n/// <reference path=\"./es/into.d.ts\" />\n/// <reference path=\"./es/invert.d.ts\" />\n/// <reference path=\"./es/invertObj.d.ts\" />\n/// <reference path=\"./es/invoker.d.ts\" />\n/// <reference path=\"./es/isArrayLike.d.ts\" />\n/// <reference path=\"./es/is.d.ts\" />\n/// <reference path=\"./es/isEmpty.d.ts\" />\n/// <reference path=\"./es/isNaN.d.ts\" />\n/// <reference path=\"./es/isNil.d.ts\" />\n/// <reference path=\"./es/join.d.ts\" />\n/// <reference path=\"./es/juxt.d.ts\" />\n/// <reference path=\"./es/keys.d.ts\" />\n/// <reference path=\"./es/keysIn.d.ts\" />\n/// <reference path=\"./es/last.d.ts\" />\n/// <reference path=\"./es/lastIndexOf.d.ts\" />\n/// <reference path=\"./es/length.d.ts\" />\n/// <reference path=\"./es/lens.d.ts\" />\n/// <reference path=\"./es/lensIndex.d.ts\" />\n/// <reference path=\"./es/lensPath.d.ts\" />\n/// <reference path=\"./es/lensProp.d.ts\" />\n/// <reference path=\"./es/lift.d.ts\" />\n/// <reference path=\"./es/lt.d.ts\" />\n/// <reference path=\"./es/lte.d.ts\" />\n/// <reference path=\"./es/mapAccum.d.ts\" />\n/// <reference path=\"./es/mapAccumRight.d.ts\" />\n/// <reference path=\"./es/map.d.ts\" />\n/// <reference path=\"./es/mapObjIndexed.d.ts\" />\n/// <reference path=\"./es/match.d.ts\" />\n/// <reference path=\"./es/mathMod.d.ts\" />\n/// <reference path=\"./es/maxBy.d.ts\" />\n/// <reference path=\"./es/max.d.ts\" />\n/// <reference path=\"./es/mean.d.ts\" />\n/// <reference path=\"./es/median.d.ts\" />\n/// <reference path=\"./es/memoize.d.ts\" />\n/// <reference path=\"./es/memoizeWith.d.ts\" />\n/// <reference path=\"./es/mergeAll.d.ts\" />\n/// <reference path=\"./es/mergeDeepLeft.d.ts\" />\n/// <reference path=\"./es/mergeDeepRight.d.ts\" />\n/// <reference path=\"./es/mergeDeepWith.d.ts\" />\n/// <reference path=\"./es/mergeDeepWithKey.d.ts\" />\n/// <reference path=\"./es/merge.d.ts\" />\n/// <reference path=\"./es/mergeWith.d.ts\" />\n/// <reference path=\"./es/mergeWithKey.d.ts\" />\n/// <reference path=\"./es/minBy.d.ts\" />\n/// <reference path=\"./es/min.d.ts\" />\n/// <reference path=\"./es/modulo.d.ts\" />\n/// <reference path=\"./es/move.d.ts\" />\n/// <reference path=\"./es/multiply.d.ts\" />\n/// <reference path=\"./es/nAry.d.ts\" />\n/// <reference path=\"./es/negate.d.ts\" />\n/// <reference path=\"./es/none.d.ts\" />\n/// <reference path=\"./es/not.d.ts\" />\n/// <reference path=\"./es/nthArg.d.ts\" />\n/// <reference path=\"./es/nth.d.ts\" />\n/// <reference path=\"./es/objOf.d.ts\" />\n/// <reference path=\"./es/of.d.ts\" />\n/// <reference path=\"./es/omit.d.ts\" />\n/// <reference path=\"./es/once.d.ts\" />\n/// <reference path=\"./es/or.d.ts\" />\n/// <reference path=\"./es/over.d.ts\" />\n/// <reference path=\"./es/pair.d.ts\" />\n/// <reference path=\"./es/partial.d.ts\" />\n/// <reference path=\"./es/partialRight.d.ts\" />\n/// <reference path=\"./es/partition.d.ts\" />\n/// <reference path=\"./es/path.d.ts\" />\n/// <reference path=\"./es/pathEq.d.ts\" />\n/// <reference path=\"./es/pathOr.d.ts\" />\n/// <reference path=\"./es/pathSatisfies.d.ts\" />\n/// <reference path=\"./es/pickAll.d.ts\" />\n/// <reference path=\"./es/pickBy.d.ts\" />\n/// <reference path=\"./es/pick.d.ts\" />\n/// <reference path=\"./es/pipe.d.ts\" />\n/// <reference path=\"./es/pipeK.d.ts\" />\n/// <reference path=\"./es/pipeP.d.ts\" />\n/// <reference path=\"./es/pluck.d.ts\" />\n/// <reference path=\"./es/prepend.d.ts\" />\n/// <reference path=\"./es/product.d.ts\" />\n/// <reference path=\"./es/project.d.ts\" />\n/// <reference path=\"./es/prop.d.ts\" />\n/// <reference path=\"./es/propEq.d.ts\" />\n/// <reference path=\"./es/propIs.d.ts\" />\n/// <reference path=\"./es/propOr.d.ts\" />\n/// <reference path=\"./es/propSatisfies.d.ts\" />\n/// <reference path=\"./es/props.d.ts\" />\n/// <reference path=\"./es/range.d.ts\" />\n/// <reference path=\"./es/reduceBy.d.ts\" />\n/// <reference path=\"./es/reduced.d.ts\" />\n/// <reference path=\"./es/reduce.d.ts\" />\n/// <reference path=\"./es/reduceRight.d.ts\" />\n/// <reference path=\"./es/reduceWhile.d.ts\" />\n/// <reference path=\"./es/reject.d.ts\" />\n/// <reference path=\"./es/remove.d.ts\" />\n/// <reference path=\"./es/repeat.d.ts\" />\n/// <reference path=\"./es/replace.d.ts\" />\n/// <reference path=\"./es/reverse.d.ts\" />\n/// <reference path=\"./es/scan.d.ts\" />\n/// <reference path=\"./es/set.d.ts\" />\n/// <reference path=\"./es/slice.d.ts\" />\n/// <reference path=\"./es/sortBy.d.ts\" />\n/// <reference path=\"./es/sort.d.ts\" />\n/// <reference path=\"./es/sortWith.d.ts\" />\n/// <reference path=\"./es/splitAt.d.ts\" />\n/// <reference path=\"./es/split.d.ts\" />\n/// <reference path=\"./es/splitEvery.d.ts\" />\n/// <reference path=\"./es/splitWhen.d.ts\" />\n/// <reference path=\"./es/startsWith.d.ts\" />\n/// <reference path=\"./es/subtract.d.ts\" />\n/// <reference path=\"./es/sum.d.ts\" />\n/// <reference path=\"./es/symmetricDifference.d.ts\" />\n/// <reference path=\"./es/symmetricDifferenceWith.d.ts\" />\n/// <reference path=\"./es/tail.d.ts\" />\n/// <reference path=\"./es/take.d.ts\" />\n/// <reference path=\"./es/takeLast.d.ts\" />\n/// <reference path=\"./es/takeLastWhile.d.ts\" />\n/// <reference path=\"./es/takeWhile.d.ts\" />\n/// <reference path=\"./es/tap.d.ts\" />\n/// <reference path=\"./es/T.d.ts\" />\n/// <reference path=\"./es/test.d.ts\" />\n/// <reference path=\"./es/times.d.ts\" />\n/// <reference path=\"./es/toLower.d.ts\" />\n/// <reference path=\"./es/toPairs.d.ts\" />\n/// <reference path=\"./es/toPairsIn.d.ts\" />\n/// <reference path=\"./es/toString.d.ts\" />\n/// <reference path=\"./es/toUpper.d.ts\" />\n/// <reference path=\"./es/transduce.d.ts\" />\n/// <reference path=\"./es/transpose.d.ts\" />\n/// <reference path=\"./es/traverse.d.ts\" />\n/// <reference path=\"./es/trim.d.ts\" />\n/// <reference path=\"./es/tryCatch.d.ts\" />\n/// <reference path=\"./es/type.d.ts\" />\n/// <reference path=\"./es/unapply.d.ts\" />\n/// <reference path=\"./es/unary.d.ts\" />\n/// <reference path=\"./es/uncurryN.d.ts\" />\n/// <reference path=\"./es/unfold.d.ts\" />\n/// <reference path=\"./es/union.d.ts\" />\n/// <reference path=\"./es/unionWith.d.ts\" />\n/// <reference path=\"./es/uniqBy.d.ts\" />\n/// <reference path=\"./es/uniq.d.ts\" />\n/// <reference path=\"./es/uniqWith.d.ts\" />\n/// <reference path=\"./es/unless.d.ts\" />\n/// <reference path=\"./es/unnest.d.ts\" />\n/// <reference path=\"./es/until.d.ts\" />\n/// <reference path=\"./es/update.d.ts\" />\n/// <reference path=\"./es/useWith.d.ts\" />\n/// <reference path=\"./es/values.d.ts\" />\n/// <reference path=\"./es/valuesIn.d.ts\" />\n/// <reference path=\"./es/view.d.ts\" />\n/// <reference path=\"./es/when.d.ts\" />\n/// <reference path=\"./es/where.d.ts\" />\n/// <reference path=\"./es/whereEq.d.ts\" />\n/// <reference path=\"./es/without.d.ts\" />\n/// <reference path=\"./es/wrap.d.ts\" />\n/// <reference path=\"./es/xprod.d.ts\" />\n/// <reference path=\"./es/zip.d.ts\" />\n/// <reference path=\"./es/zipObj.d.ts\" />\n/// <reference path=\"./es/zipWith.d.ts\" />\n/// <reference path=\"./es/includes.d.ts\" />\n/// <reference path=\"./tools.d.ts\" />\n\n/// <reference path=\"./src/add.d.ts\" />\n/// <reference path=\"./src/addIndex.d.ts\" />\n/// <reference path=\"./src/adjust.d.ts\" />\n/// <reference path=\"./src/all.d.ts\" />\n/// <reference path=\"./src/allPass.d.ts\" />\n/// <reference path=\"./src/always.d.ts\" />\n/// <reference path=\"./src/and.d.ts\" />\n/// <reference path=\"./src/any.d.ts\" />\n/// <reference path=\"./src/anyPass.d.ts\" />\n/// <reference path=\"./src/ap.d.ts\" />\n/// <reference path=\"./src/aperture.d.ts\" />\n/// <reference path=\"./src/append.d.ts\" />\n/// <reference path=\"./src/apply.d.ts\" />\n/// <reference path=\"./src/applySpec.d.ts\" />\n/// <reference path=\"./src/applyTo.d.ts\" />\n/// <reference path=\"./src/ascend.d.ts\" />\n/// <reference path=\"./src/assoc.d.ts\" />\n/// <reference path=\"./src/assocPath.d.ts\" />\n/// <reference path=\"./src/binary.d.ts\" />\n/// <reference path=\"./src/bind.d.ts\" />\n/// <reference path=\"./src/both.d.ts\" />\n/// <reference path=\"./src/call.d.ts\" />\n/// <reference path=\"./src/chain.d.ts\" />\n/// <reference path=\"./src/clamp.d.ts\" />\n/// <reference path=\"./src/clone.d.ts\" />\n/// <reference path=\"./src/comparator.d.ts\" />\n/// <reference path=\"./src/complement.d.ts\" />\n/// <reference path=\"./src/compose.d.ts\" />\n/// <reference path=\"./src/composeK.d.ts\" />\n/// <reference path=\"./src/composeP.d.ts\" />\n/// <reference path=\"./src/concat.d.ts\" />\n/// <reference path=\"./src/cond.d.ts\" />\n/// <reference path=\"./src/construct.d.ts\" />\n/// <reference path=\"./src/constructN.d.ts\" />\n/// <reference path=\"./src/contains.d.ts\" />\n/// <reference path=\"./src/converge.d.ts\" />\n/// <reference path=\"./src/countBy.d.ts\" />\n/// <reference path=\"./src/curry.d.ts\" />\n/// <reference path=\"./src/curryN.d.ts\" />\n/// <reference path=\"./src/dec.d.ts\" />\n/// <reference path=\"./src/defaultTo.d.ts\" />\n/// <reference path=\"./src/descend.d.ts\" />\n/// <reference path=\"./src/difference.d.ts\" />\n/// <reference path=\"./src/differenceWith.d.ts\" />\n/// <reference path=\"./src/dissoc.d.ts\" />\n/// <reference path=\"./src/dissocPath.d.ts\" />\n/// <reference path=\"./src/divide.d.ts\" />\n/// <reference path=\"./src/drop.d.ts\" />\n/// <reference path=\"./src/dropLast.d.ts\" />\n/// <reference path=\"./src/dropLastWhile.d.ts\" />\n/// <reference path=\"./src/either.d.ts\" />\n/// <reference path=\"./src/empty.d.ts\" />\n/// <reference path=\"./src/endsWith.d.ts\" />\n/// <reference path=\"./src/eqBy.d.ts\" />\n/// <reference path=\"./src/eqProps.d.ts\" />\n/// <reference path=\"./src/equals.d.ts\" />\n/// <reference path=\"./src/evolve.d.ts\" />\n/// <reference path=\"./src/F.d.ts\" />\n/// <reference path=\"./src/filter.d.ts\" />\n/// <reference path=\"./src/find.d.ts\" />\n/// <reference path=\"./src/findIndex.d.ts\" />\n/// <reference path=\"./src/findLast.d.ts\" />\n/// <reference path=\"./src/findLastIndex.d.ts\" />\n/// <reference path=\"./src/flatten.d.ts\" />\n/// <reference path=\"./src/flip.d.ts\" />\n/// <reference path=\"./src/forEach.d.ts\" />\n/// <reference path=\"./src/forEachObjIndexed.d.ts\" />\n/// <reference path=\"./src/fromPairs.d.ts\" />\n/// <reference path=\"./src/groupBy.d.ts\" />\n/// <reference path=\"./src/groupWith.d.ts\" />\n/// <reference path=\"./src/gt.d.ts\" />\n/// <reference path=\"./src/gte.d.ts\" />\n/// <reference path=\"./src/has.d.ts\" />\n/// <reference path=\"./src/hasIn.d.ts\" />\n/// <reference path=\"./src/head.d.ts\" />\n/// <reference path=\"./src/identical.d.ts\" />\n/// <reference path=\"./src/identity.d.ts\" />\n/// <reference path=\"./src/ifElse.d.ts\" />\n/// <reference path=\"./src/inc.d.ts\" />\n/// <reference path=\"./src/indexBy.d.ts\" />\n/// <reference path=\"./src/indexOf.d.ts\" />\n/// <reference path=\"./src/init.d.ts\" />\n/// <reference path=\"./src/innerJoin.d.ts\" />\n/// <reference path=\"./src/insertAll.d.ts\" />\n/// <reference path=\"./src/insert.d.ts\" />\n/// <reference path=\"./src/intersection.d.ts\" />\n/// <reference path=\"./src/intersectionWith.d.ts\" />\n/// <reference path=\"./src/intersperse.d.ts\" />\n/// <reference path=\"./src/into.d.ts\" />\n/// <reference path=\"./src/invert.d.ts\" />\n/// <reference path=\"./src/invertObj.d.ts\" />\n/// <reference path=\"./src/invoker.d.ts\" />\n/// <reference path=\"./src/isArrayLike.d.ts\" />\n/// <reference path=\"./src/is.d.ts\" />\n/// <reference path=\"./src/isEmpty.d.ts\" />\n/// <reference path=\"./src/isNaN.d.ts\" />\n/// <reference path=\"./src/isNil.d.ts\" />\n/// <reference path=\"./src/join.d.ts\" />\n/// <reference path=\"./src/juxt.d.ts\" />\n/// <reference path=\"./src/keys.d.ts\" />\n/// <reference path=\"./src/keysIn.d.ts\" />\n/// <reference path=\"./src/last.d.ts\" />\n/// <reference path=\"./src/lastIndexOf.d.ts\" />\n/// <reference path=\"./src/length.d.ts\" />\n/// <reference path=\"./src/lens.d.ts\" />\n/// <reference path=\"./src/lensIndex.d.ts\" />\n/// <reference path=\"./src/lensPath.d.ts\" />\n/// <reference path=\"./src/lensProp.d.ts\" />\n/// <reference path=\"./src/lift.d.ts\" />\n/// <reference path=\"./src/lt.d.ts\" />\n/// <reference path=\"./src/lte.d.ts\" />\n/// <reference path=\"./src/mapAccum.d.ts\" />\n/// <reference path=\"./src/mapAccumRight.d.ts\" />\n/// <reference path=\"./src/map.d.ts\" />\n/// <reference path=\"./src/mapObjIndexed.d.ts\" />\n/// <reference path=\"./src/match.d.ts\" />\n/// <reference path=\"./src/mathMod.d.ts\" />\n/// <reference path=\"./src/maxBy.d.ts\" />\n/// <reference path=\"./src/max.d.ts\" />\n/// <reference path=\"./src/mean.d.ts\" />\n/// <reference path=\"./src/median.d.ts\" />\n/// <reference path=\"./src/memoize.d.ts\" />\n/// <reference path=\"./src/memoizeWith.d.ts\" />\n/// <reference path=\"./src/mergeAll.d.ts\" />\n/// <reference path=\"./src/mergeDeepLeft.d.ts\" />\n/// <reference path=\"./src/mergeDeepRight.d.ts\" />\n/// <reference path=\"./src/mergeDeepWith.d.ts\" />\n/// <reference path=\"./src/mergeDeepWithKey.d.ts\" />\n/// <reference path=\"./src/merge.d.ts\" />\n/// <reference path=\"./src/mergeWith.d.ts\" />\n/// <reference path=\"./src/mergeWithKey.d.ts\" />\n/// <reference path=\"./src/minBy.d.ts\" />\n/// <reference path=\"./src/min.d.ts\" />\n/// <reference path=\"./src/modulo.d.ts\" />\n/// <reference path=\"./src/move.d.ts\" />\n/// <reference path=\"./src/multiply.d.ts\" />\n/// <reference path=\"./src/nAry.d.ts\" />\n/// <reference path=\"./src/negate.d.ts\" />\n/// <reference path=\"./src/none.d.ts\" />\n/// <reference path=\"./src/not.d.ts\" />\n/// <reference path=\"./src/nthArg.d.ts\" />\n/// <reference path=\"./src/nth.d.ts\" />\n/// <reference path=\"./src/objOf.d.ts\" />\n/// <reference path=\"./src/of.d.ts\" />\n/// <reference path=\"./src/omit.d.ts\" />\n/// <reference path=\"./src/once.d.ts\" />\n/// <reference path=\"./src/or.d.ts\" />\n/// <reference path=\"./src/over.d.ts\" />\n/// <reference path=\"./src/pair.d.ts\" />\n/// <reference path=\"./src/partial.d.ts\" />\n/// <reference path=\"./src/partialRight.d.ts\" />\n/// <reference path=\"./src/partition.d.ts\" />\n/// <reference path=\"./src/path.d.ts\" />\n/// <reference path=\"./src/pathEq.d.ts\" />\n/// <reference path=\"./src/pathOr.d.ts\" />\n/// <reference path=\"./src/pathSatisfies.d.ts\" />\n/// <reference path=\"./src/pickAll.d.ts\" />\n/// <reference path=\"./src/pickBy.d.ts\" />\n/// <reference path=\"./src/pick.d.ts\" />\n/// <reference path=\"./src/pipe.d.ts\" />\n/// <reference path=\"./src/pipeK.d.ts\" />\n/// <reference path=\"./src/pipeP.d.ts\" />\n/// <reference path=\"./src/pluck.d.ts\" />\n/// <reference path=\"./src/prepend.d.ts\" />\n/// <reference path=\"./src/product.d.ts\" />\n/// <reference path=\"./src/project.d.ts\" />\n/// <reference path=\"./src/prop.d.ts\" />\n/// <reference path=\"./src/propEq.d.ts\" />\n/// <reference path=\"./src/propIs.d.ts\" />\n/// <reference path=\"./src/propOr.d.ts\" />\n/// <reference path=\"./src/propSatisfies.d.ts\" />\n/// <reference path=\"./src/props.d.ts\" />\n/// <reference path=\"./src/range.d.ts\" />\n/// <reference path=\"./src/reduceBy.d.ts\" />\n/// <reference path=\"./src/reduced.d.ts\" />\n/// <reference path=\"./src/reduce.d.ts\" />\n/// <reference path=\"./src/reduceRight.d.ts\" />\n/// <reference path=\"./src/reduceWhile.d.ts\" />\n/// <reference path=\"./src/reject.d.ts\" />\n/// <reference path=\"./src/remove.d.ts\" />\n/// <reference path=\"./src/repeat.d.ts\" />\n/// <reference path=\"./src/replace.d.ts\" />\n/// <reference path=\"./src/reverse.d.ts\" />\n/// <reference path=\"./src/scan.d.ts\" />\n/// <reference path=\"./src/set.d.ts\" />\n/// <reference path=\"./src/slice.d.ts\" />\n/// <reference path=\"./src/sortBy.d.ts\" />\n/// <reference path=\"./src/sort.d.ts\" />\n/// <reference path=\"./src/sortWith.d.ts\" />\n/// <reference path=\"./src/splitAt.d.ts\" />\n/// <reference path=\"./src/split.d.ts\" />\n/// <reference path=\"./src/splitEvery.d.ts\" />\n/// <reference path=\"./src/splitWhen.d.ts\" />\n/// <reference path=\"./src/startsWith.d.ts\" />\n/// <reference path=\"./src/subtract.d.ts\" />\n/// <reference path=\"./src/sum.d.ts\" />\n/// <reference path=\"./src/symmetricDifference.d.ts\" />\n/// <reference path=\"./src/symmetricDifferenceWith.d.ts\" />\n/// <reference path=\"./src/tail.d.ts\" />\n/// <reference path=\"./src/take.d.ts\" />\n/// <reference path=\"./src/takeLast.d.ts\" />\n/// <reference path=\"./src/takeLastWhile.d.ts\" />\n/// <reference path=\"./src/takeWhile.d.ts\" />\n/// <reference path=\"./src/tap.d.ts\" />\n/// <reference path=\"./src/T.d.ts\" />\n/// <reference path=\"./src/test.d.ts\" />\n/// <reference path=\"./src/times.d.ts\" />\n/// <reference path=\"./src/toLower.d.ts\" />\n/// <reference path=\"./src/toPairs.d.ts\" />\n/// <reference path=\"./src/toPairsIn.d.ts\" />\n/// <reference path=\"./src/toString.d.ts\" />\n/// <reference path=\"./src/toUpper.d.ts\" />\n/// <reference path=\"./src/transduce.d.ts\" />\n/// <reference path=\"./src/transpose.d.ts\" />\n/// <reference path=\"./src/traverse.d.ts\" />\n/// <reference path=\"./src/trim.d.ts\" />\n/// <reference path=\"./src/tryCatch.d.ts\" />\n/// <reference path=\"./src/type.d.ts\" />\n/// <reference path=\"./src/unapply.d.ts\" />\n/// <reference path=\"./src/unary.d.ts\" />\n/// <reference path=\"./src/uncurryN.d.ts\" />\n/// <reference path=\"./src/unfold.d.ts\" />\n/// <reference path=\"./src/union.d.ts\" />\n/// <reference path=\"./src/unionWith.d.ts\" />\n/// <reference path=\"./src/uniqBy.d.ts\" />\n/// <reference path=\"./src/uniq.d.ts\" />\n/// <reference path=\"./src/uniqWith.d.ts\" />\n/// <reference path=\"./src/unless.d.ts\" />\n/// <reference path=\"./src/unnest.d.ts\" />\n/// <reference path=\"./src/until.d.ts\" />\n/// <reference path=\"./src/update.d.ts\" />\n/// <reference path=\"./src/useWith.d.ts\" />\n/// <reference path=\"./src/values.d.ts\" />\n/// <reference path=\"./src/valuesIn.d.ts\" />\n/// <reference path=\"./src/view.d.ts\" />\n/// <reference path=\"./src/when.d.ts\" />\n/// <reference path=\"./src/where.d.ts\" />\n/// <reference path=\"./src/whereEq.d.ts\" />\n/// <reference path=\"./src/without.d.ts\" />\n/// <reference path=\"./src/wrap.d.ts\" />\n/// <reference path=\"./src/xprod.d.ts\" />\n/// <reference path=\"./src/zip.d.ts\" />\n/// <reference path=\"./src/zipObj.d.ts\" />\n/// <reference path=\"./src/zipWith.d.ts\" />\n/// <reference path=\"./src/includes.d.ts\" />\n\ndeclare let R: R.Static;\n\ndeclare namespace R {\n  type Omit<T, K extends string> = Pick<T, Exclude<keyof T, K>>;\n\n  type Ord = number | string | boolean | Date;\n\n  type Path = ReadonlyArray<(number | string)>;\n\n  interface Functor<T> {\n    map<U>(fn: (t: T) => U): Functor<U>;\n  }\n\n  interface KeyValuePair<K, V> extends Array<K | V> {\n    0: K;\n    1: V;\n  }\n\n  interface ArrayLike {\n    nodeType: number;\n  }\n\n  type Arity0Fn = () => any;\n\n  type Arity1Fn = (a: any) => any;\n\n  type Arity2Fn = (a: any, b: any) => any;\n\n  interface ObjFunc {\n    [index: string]: (...a: any[]) => any;\n  }\n\n  interface ObjFunc2 {\n    [index: string]: (x: any, y: any) => boolean;\n  }\n\n  type Pred = (...a: any[]) => boolean;\n  type SafePred<T> = (...a: T[]) => boolean;\n\n  type ObjPred = (value: any, key: string) => boolean;\n\n  interface Dictionary<T> {\n    [index: string]: T;\n  }\n\n  interface CharList extends String {\n    push(x: string): void;\n  }\n\n  interface Lens {\n    <T, U>(obj: T): U;\n    set<T, U>(str: string, obj: T): U;\n  }\n\n  interface Filter {\n    <T>(fn: (value: T) => boolean): FilterOnceApplied<T>;\n    <T, Kind extends 'array'>(fn: (value: T) => boolean): (list: ReadonlyArray<T>) => T[];\n    <T, Kind extends 'object'>(fn: (value: T) => boolean): (list: Dictionary<T>) => Dictionary<T>;\n    <T>(fn: (value: T) => boolean, list: ReadonlyArray<T>): T[];\n    <T>(fn: (value: T) => boolean, obj: Dictionary<T>): Dictionary<T>;\n  }\n\n  interface FilterOnceApplied<T> {\n    (list: ReadonlyArray<T>): T[];\n    (obj: Dictionary<T>): Dictionary<T>;\n  }\n\n  type Evolve<O extends Evolvable<E>, E extends Evolver> = {\n    [P in keyof O]: P extends keyof E ? EvolveValue<O[P], E[P]> : O[P];\n  };\n\n  type EvolveValue<V, E> =\n    E extends (value: V) => any ? ReturnType<E> :\n      E extends Evolver ? EvolveNestedValue<V, E> :\n        never;\n\n  type EvolveNestedValue<V, E extends Evolver> =\n    V extends object ? (V extends Evolvable<E> ? Evolve<V, E> : never) : never;\n\n  interface Evolver {\n    [key: string]: ((value: any) => any) | Evolver;\n  }\n\n  // Represents all objects evolvable with Evolver E\n  type Evolvable<E extends Evolver> = {\n    [P in keyof E]?: Evolved<E[P]>;\n  };\n\n  type Evolved<T> =\n    T extends (value: infer V) => any ? V :\n      T extends Evolver ? Evolvable<T> :\n        never;\n\n  interface Placeholder { __isRamdaPlaceholder__: true; }\n\n  interface Reduced<T> {\n    '@@transducer/value': T;\n    '@@transducer/reduced': true;\n  }\n\n  interface Static {\n    /**\n     * Placeholder. When used with functions like curry, or op, the second argument is applied to the second\n     * position, and it returns a function waiting for its first argument.\n     */\n    __: Placeholder; /* This is used in examples throughout the docs, but I it only seems to be directly explained here: https://ramdajs.com/0.9/docs/#op */\n\n    /**\n     * Adds two numbers (or strings). Equivalent to a + b but curried.\n     */\n    add(a: number, b: number): number;\n    add(a: string, b: string): string;\n    add(a: number): (b: number) => number;\n    add(a: string): (b: string) => string;\n\n    /**\n     * Creates a new list iteration function from an existing one by adding two new parameters to its callback\n     * function: the current index, and the entire list.\n     */\n    addIndex<T, U>(fn: (f: (item: T) => U, list: T[]) => U[]): Curry.Curry<(a: (item: T, idx: number, list?: T[]) => U, b: ReadonlyArray<T>) => U[]>;\n    /* Special case for forEach */\n    addIndex<T>(fn: (f: (item: T) => void, list: T[]) => T[]): Curry.Curry<(a: (item: T, idx: number, list?: T[]) => void, b: ReadonlyArray<T>) => T[]>;\n    /* Special case for reduce */\n    addIndex<T, U>(fn: (f: (acc: U, item: T) => U, aci: U, list: T[]) => U): Curry.Curry<(a: (acc: U, item: T, idx: number, list?: T[]) => U, b: U, c: ReadonlyArray<T>) => U>;\n\n    /**\n     * Applies a function to the value at the given index of an array, returning a new copy of the array with the\n     * element at the given index replaced with the result of the function application.\n     */\n    adjust<T>(index: number, fn: (a: T) => T, list: ReadonlyArray<T>): T[];\n    adjust<T>(index: number, fn: (a: T) => T): (list: ReadonlyArray<T>) => T[];\n\n    /**\n     * Returns true if all elements of the list match the predicate, false if there are any that don't.\n     */\n    all<T>(fn: (a: T) => boolean, list: ReadonlyArray<T>): boolean;\n    all<T>(fn: (a: T) => boolean): (list: ReadonlyArray<T>) => boolean;\n\n    /**\n     * Given a list of predicates, returns a new predicate that will be true exactly when all of them are.\n     */\n    allPass(preds: ReadonlyArray<Pred>): Pred;\n\n    /**\n     * Returns a function that always returns the given value.\n     */\n    always<T>(val: T): () => T;\n\n    /**\n     * A function that returns the first argument if it's falsy otherwise the second argument. Note that this is\n     * NOT short-circuited, meaning that if expressions are passed they are both evaluated.\n     */\n    and<T extends { and?: ((...a: any[]) => any); } | number | boolean | string | null>(fn1: T, val2: any): boolean;\n    and<T extends { and?: ((...a: any[]) => any); } | number | boolean | string | null>(fn1: T): (val2: any) => boolean;\n\n    /**\n     * Returns true if at least one of elements of the list match the predicate, false otherwise.\n     */\n    any<T>(fn: (a: T) => boolean, list: ReadonlyArray<T>): boolean;\n    any<T>(fn: (a: T) => boolean): (list: ReadonlyArray<T>) => boolean;\n\n    /**\n     * Given a list of predicates returns a new predicate that will be true exactly when any one of them is.\n     */\n    anyPass<T>(preds: ReadonlyArray<SafePred<T>>): SafePred<T>;\n\n    /**\n     * ap applies a list of functions to a list of values.\n     */\n    ap<T, U>(fns: Array<((a: T) => U)>, vs: ReadonlyArray<T>): U[];\n    ap<T, U>(fns: Array<((a: T) => U)>): (vs: ReadonlyArray<T>) => U[];\n\n    /**\n     * Returns a new list, composed of n-tuples of consecutive elements If n is greater than the length of the list,\n     * an empty list is returned.\n     */\n    aperture<T>(n: 1, list: T[]): Array<[T]>;\n    aperture<T>(n: 2, list: T[]): Array<[T, T]>;\n    aperture<T>(n: 3, list: T[]): Array<[T, T, T]>;\n    aperture<T>(n: 4, list: T[]): Array<[T, T, T, T]>;\n    aperture<T>(n: 5, list: T[]): Array<[T, T, T, T, T]>;\n    aperture<T>(n: 6, list: T[]): Array<[T, T, T, T, T, T]>;\n    aperture<T>(n: 7, list: T[]): Array<[T, T, T, T, T, T, T]>;\n    aperture<T>(n: 8, list: T[]): Array<[T, T, T, T, T, T, T, T]>;\n    aperture<T>(n: 9, list: T[]): Array<[T, T, T, T, T, T, T, T, T]>;\n    aperture<T>(n: 10, list: T[]): Array<[T, T, T, T, T, T, T, T, T, T]>;\n    aperture<T>(n: number, list: ReadonlyArray<T>): T[][];\n    aperture(n: number): <T>(list: ReadonlyArray<T>) => T[][];\n\n    /**\n     * Returns a new list containing the contents of the given list, followed by the given element.\n     */\n    append<T>(el: T, list: ReadonlyArray<T>): T[];\n    append<T>(el: T): <T>(list: ReadonlyArray<T>) => T[];\n\n    /**\n     * Applies function fn to the argument list args. This is useful for creating a fixed-arity function from\n     * a variadic function. fn should be a bound function if context is significant.\n     */\n    apply<T, U, TResult>(fn: (arg0: T, ...args: T[]) => TResult, args: ReadonlyArray<U>): TResult;\n    apply<T, TResult>(fn: (arg0: T, ...args: T[]) => TResult): <U>(args: ReadonlyArray<U>) => TResult;\n\n    /**\n     * Given a spec object recursively mapping properties to functions, creates a function producing an object\n     * of the same structure, by mapping each property to the result of calling its associated function with\n     * the supplied arguments.\n     */\n    applySpec<T>(obj: any): (...args: any[]) => T;\n\n    /**\n     * Takes a value and applies a function to it.\n     * This function is also known as the thrush combinator.\n     */\n    applyTo<T, U>(el: T, fn: (t: T) => U): U;\n    applyTo<T>(el: T): <U>(fn: (t: T) => U) => U;\n\n    /**\n     * Makes an ascending comparator function out of a function that returns a value that can be compared with < and >.\n     */\n    ascend<T>(fn: (obj: T) => any, a: T, b: T): number;\n    ascend<T>(fn: (obj: T) => any): (a: T, b: T) => number;\n\n    /**\n     * Makes a shallow clone of an object, setting or overriding the specified property with the given value.\n     */\n    assoc<T, U>(__: Placeholder, val: T, obj: U): <K extends string>(prop: K) => Record<K, T> & U;\n    assoc<U, K extends string>(prop: K, __: Placeholder, obj: U): <T>(val: T) => Record<K, T> & U;\n    assoc<T, U, K extends string>(prop: K, val: T, obj: U): Record<K, T> & U;\n    assoc<T, K extends string>(prop: K, val: T): <U>(obj: U) => Record<K, T> & U;\n    assoc<K extends string>(prop: K): <T, U>(val: T, obj: U) => Record<K, T> & U;\n\n    /**\n     * Makes a shallow clone of an object, setting or overriding the nodes required to create the given path, and\n     * placing the specific value at the tail end of that path.\n     */\n    assocPath<T, U>(__: Placeholder, val: T, obj: U): (path: Path) => U;\n    assocPath<T, U>(path: Path, __: Placeholder, obj: U): (val: T) => U;\n    assocPath<T, U>(path: Path, val: T, obj: U): U;\n    assocPath<T, U>(path: Path, val: T): (obj: U) => U;\n    assocPath<T, U>(path: Path): Curry.Curry<(a: T, b: U) => U>;\n\n    /**\n     * Wraps a function of any arity (including nullary) in a function that accepts exactly 2\n     * parameters. Any extraneous parameters will not be passed to the supplied function.\n     */\n    binary(fn: (...args: any[]) => any): (...a: any[]) => any;\n\n    /**\n     * Creates a function that is bound to a context. Note: R.bind does not provide the additional argument-binding\n     * capabilities of Function.prototype.bind.\n     */\n    bind<T>(fn: (...args: any[]) => any, thisObj: T): (...args: any[]) => any;\n\n    /**\n     * A function wrapping calls to the two functions in an && operation, returning the result of the first function\n     * if it is false-y and the result of the second function otherwise. Note that this is short-circuited, meaning\n     * that the second function will not be invoked if the first returns a false-y value.\n     */\n    both(pred1: Pred, pred2: Pred): Pred;\n    both(pred1: Pred): (pred2: Pred) => Pred;\n\n    /**\n     * Returns the result of calling its first argument with the remaining arguments. This is occasionally useful\n     * as a converging function for R.converge: the left branch can produce a function while the right branch\n     * produces a value to be passed to that function as an argument.\n     */\n    call(fn: (...args: any[]) => (...args: any[]) => any, ...args: any[]): any;\n\n    /**\n     * chain maps a function over a list and concatenates the results.\n     * This implementation is compatible with the Fantasy-land Chain spec\n     */\n    chain<T, U>(fn: (n: T) => ReadonlyArray<U>, list: ReadonlyArray<T>): U[];\n    chain<T, U>(fn: (n: T) => ReadonlyArray<U>): (list: ReadonlyArray<T>) => U[];\n\n    /**\n     * Restricts a number to be within a range.\n     * Also works for other ordered types such as Strings and Date\n     */\n    clamp<T>(min: T, max: T, value: T): T;\n    clamp<T>(min: T, max: T): (value: T) => T;\n    clamp<T>(min: T): (max: T, value: T) => T;\n    clamp<T>(min: T): (max: T) => (value: T) => T;\n\n    /**\n     * Creates a deep copy of the value which may contain (nested) Arrays and Objects, Numbers, Strings, Booleans and Dates.\n     */\n    clone<T>(value: T): T;\n    clone<T>(value: ReadonlyArray<T>): T[];\n\n    /**\n     * Makes a comparator function out of a function that reports whether the first element is less than the second.\n     */\n    // comparator(pred: (a: any, b: any) => boolean): (x: number, y: number) => number;\n    comparator<T>(pred: (a: T, b: T) => boolean): (x: T, y: T) => number;\n\n    /**\n     * Takes a function f and returns a function g such that:\n     * - applying g to zero or more arguments will give true if applying the same arguments to f gives\n     *   a logical false value; and\n     * - applying g to zero or more arguments will give false if applying the same arguments to f gives\n     *   a logical true value.\n     */\n    complement(pred: (...args: any[]) => boolean): (...args: any[]) => boolean;\n\n    /**\n     * Performs right-to-left function composition. The rightmost function may have any arity; the remaining\n     * functions must be unary.\n     */\n\n    // generic rest parameters in TS 3.0 allows writing a single variant for any number of Vx\n    // compose<V extends any[], T1>(fn0: (...args: V) => T1): (...args: V) => T1;\n    // compose<V extends any[], T1, T2>(fn1: (x: T1) => T2, fn0: (...args: V) => T1): (...args: V) => T2;\n    // but requiring TS>=3.0 sounds like a breaking change, so just leaving a comment for the future\n\n    compose<T1>(fn0: () => T1): () => T1;\n    compose<V0, T1>(fn0: (x0: V0) => T1): (x0: V0) => T1;\n    compose<V0, V1, T1>(fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T1;\n    compose<V0, V1, V2, T1>(fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T1;\n\n    compose<T1, T2>(fn1: (x: T1) => T2, fn0: () => T1): () => T2;\n    compose<V0, T1, T2>(fn1: (x: T1) => T2, fn0: (x0: V0) => T1): (x0: V0) => T2;\n    compose<V0, V1, T1, T2>(fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T2;\n    compose<V0, V1, V2, T1, T2>(fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T2;\n\n    compose<T1, T2, T3>(fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: () => T1): () => T3;\n    compose<V0, T1, T2, T3>(fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x: V0) => T1): (x: V0) => T3;\n    compose<V0, V1, T1, T2, T3>(fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T3;\n    compose<V0, V1, V2, T1, T2, T3>(fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T3;\n\n    compose<T1, T2, T3, T4>(fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: () => T1): () => T4;\n    compose<V0, T1, T2, T3, T4>(fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x: V0) => T1): (x: V0) => T4;\n    compose<V0, V1, T1, T2, T3, T4>(fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T4;\n    compose<V0, V1, V2, T1, T2, T3, T4>(fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T4;\n\n    compose<T1, T2, T3, T4, T5>(fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: () => T1): () => T5;\n    compose<V0, T1, T2, T3, T4, T5>(fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x: V0) => T1): (x: V0) => T5;\n    compose<V0, V1, T1, T2, T3, T4, T5>(fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T5;\n    compose<V0, V1, V2, T1, T2, T3, T4, T5>(fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T5;\n\n    compose<T1, T2, T3, T4, T5, T6>(fn5: (x: T5) => T6, fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: () => T1): () => T6;\n    compose<V0, T1, T2, T3, T4, T5, T6>(fn5: (x: T5) => T6, fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x: V0) => T1): (x: V0) => T6;\n    compose<V0, V1, T1, T2, T3, T4, T5, T6>(\n      fn5: (x: T5) => T6,\n      fn4: (x: T4) => T5,\n      fn3: (x: T3) => T4,\n      fn2: (x: T2) => T3,\n      fn1: (x: T1) => T2,\n      fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T6;\n    compose<V0, V1, V2, T1, T2, T3, T4, T5, T6>(\n      fn5: (x: T5) => T6,\n      fn4: (x: T4) => T5,\n      fn3: (x: T3) => T4,\n      fn2: (x: T2) => T3,\n      fn1: (x: T1) => T2,\n      fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T6;\n\n    /**\n     * Returns the right-to-left Kleisli composition of the provided functions, each of which must return a value of a type supported by chain.\n     * The typings only support arrays for now.\n     * All functions must be unary.\n     * R.composeK(h, g, f) is equivalent to R.compose(R.chain(h), R.chain(g), f).\n     */\n    composeK<V0, T1>(\n      fn0: (x0: V0) => T1[]): (x0: V0) => T1[];\n    composeK<V0, T1, T2>(\n      fn1: (x: T1) => T2[],\n      fn0: (x0: V0) => T1[]): (x0: V0) => T2[];\n    composeK<V0, T1, T2, T3>(\n      fn2: (x: T2) => T3[],\n      fn1: (x: T1) => T2[],\n      fn0: (x: V0) => T1[]): (x: V0) => T3[];\n    composeK<V0, T1, T2, T3, T4>(\n      fn3: (x: T3) => T4[],\n      fn2: (x: T2) => T3[],\n      fn1: (x: T1) => T2[],\n      fn0: (x: V0) => T1[]): (x: V0) => T4[];\n    composeK<V0, T1, T2, T3, T4, T5>(\n      fn4: (x: T4) => T5[],\n      fn3: (x: T3) => T4[],\n      fn2: (x: T2) => T3[],\n      fn1: (x: T1) => T2[],\n      fn0: (x: V0) => T1[]): (x: V0) => T5[];\n    composeK<V0, T1, T2, T3, T4, T5, T6>(\n      fn5: (x: T5) => T6[],\n      fn4: (x: T4) => T5[],\n      fn3: (x: T3) => T4[],\n      fn2: (x: T2) => T3[],\n      fn1: (x: T1) => T2[],\n      fn0: (x: V0) => T1[]): (x: V0) => T6[];\n\n    /**\n     * Performs right-to-left composition of one or more Promise-returning functions.\n     * All functions must be unary.\n     */\n    composeP<V0, T1>(\n      fn0: (x0: V0) => Promise<T1>): (x0: V0) => Promise<T1>;\n    composeP<V0, T1, T2>(\n      fn1: (x: T1) => Promise<T2>,\n      fn0: (x0: V0) => Promise<T1>): (x0: V0) => Promise<T2>;\n    composeP<V0, T1, T2, T3>(\n      fn2: (x: T2) => Promise<T3>,\n      fn1: (x: T1) => Promise<T2>,\n      fn0: (x: V0) => Promise<T1>): (x: V0) => Promise<T3>;\n    composeP<V0, T1, T2, T3, T4>(\n      fn3: (x: T3) => Promise<T4>,\n      fn2: (x: T2) => Promise<T3>,\n      fn1: (x: T1) => Promise<T2>,\n      fn0: (x: V0) => Promise<T1>): (x: V0) => Promise<T4>;\n    composeP<V0, T1, T2, T3, T4, T5>(\n      fn4: (x: T4) => Promise<T5>,\n      fn3: (x: T3) => Promise<T4>,\n      fn2: (x: T2) => Promise<T3>,\n      fn1: (x: T1) => Promise<T2>,\n      fn0: (x: V0) => Promise<T1>):\n      (x: V0) => Promise<T5>;\n    composeP<V0, T1, T2, T3, T4, T5, T6>(\n      fn5: (x: T5) => Promise<T6>,\n      fn4: (x: T4) => Promise<T5>,\n      fn3: (x: T3) => Promise<T4>,\n      fn2: (x: T2) => Promise<T3>,\n      fn1: (x: T1) => Promise<T2>,\n      fn0: (x: V0) => Promise<T1>):\n      (x: V0) => Promise<T6>;\n\n    /**\n     * Returns a new list consisting of the elements of the first list followed by the elements\n     * of the second.\n     */\n    concat<T>(placeholder: Placeholder): (list2: ReadonlyArray<T>, list1: ReadonlyArray<T>) => T[];\n    concat<T>(placeholder: Placeholder, list2: ReadonlyArray<T>): (list1: ReadonlyArray<T>) => T[];\n    concat<T>(list1: ReadonlyArray<T>, list2: ReadonlyArray<T>): T[];\n    concat<T>(list1: ReadonlyArray<T>): (list2: ReadonlyArray<T>) => T[];\n    concat(list1: string, list2: string): string;\n    concat(list1: string): (list2: string) => string;\n\n    /**\n     * Returns a function, fn, which encapsulates if/else-if/else logic. R.cond takes a list of [predicate, transform] pairs.\n     * All of the arguments to fn are applied to each of the predicates in turn until one returns a \"truthy\" value, at which\n     * point fn returns the result of applying its arguments to the corresponding transformer. If none of the predicates\n     * matches, fn returns undefined.\n     */\n    cond(fns: ReadonlyArray<[Pred, (...a: any[]) => any]>): (...a: any[]) => any;\n    cond<A, B>(fns: ReadonlyArray<[SafePred<A>, (...a: A[]) => B]>): (...a: A[]) => B;\n\n    /**\n     * Wraps a constructor function inside a curried function that can be called with the same arguments and returns the same type.\n     */\n    construct(fn: (...a: any[]) => any): (...a: any[]) => any;\n\n    /**\n     * Wraps a constructor function inside a curried function that can be called with the same arguments and returns the same type.\n     * The arity of the function returned is specified to allow using variadic constructor functions.\n     */\n    constructN(n: number, fn: (...a: any[]) => any): (...a: any[]) => any;\n\n    /**\n     * Returns true if the specified item is somewhere in the list, false otherwise.\n     * Equivalent to indexOf(a)(list) > -1. Uses strict (===) equality checking.\n     */\n    contains(__: Placeholder, list: string): (a: string) => boolean;\n    contains<T>(__: Placeholder, list: T[]): (a: T) => boolean;\n    contains(__: Placeholder): (list: string, a: string) => boolean;\n    contains<T>(__: Placeholder): (list: T[], a: T) => boolean;\n    contains(a: string, list: string): boolean;\n    contains<T>(a: T, list: ReadonlyArray<T>): boolean;\n    contains(a: string): (list: string) => boolean;\n    contains<T>(a: T): (list: ReadonlyArray<T>) => boolean;\n\n    /**\n     * Accepts a converging function and a list of branching functions and returns a new\n     * function. When invoked, this new function is applied to some arguments, each branching\n     * function is applied to those same arguments. The results of each branching function\n     * are passed as arguments to the converging function to produce the return value.\n     */\n    converge(after: ((...a: any[]) => any), fns: ReadonlyArray<((...a: any[]) => any)>): (...a: any[]) => any;\n\n    /**\n     * Counts the elements of a list according to how many match each value\n     * of a key generated by the supplied function. Returns an object\n     * mapping the keys produced by fn to the number of occurrences in\n     * the list. Note that all keys are coerced to strings because of how\n     * JavaScript objects work.\n     */\n    countBy<T>(fn: (a: T) => string | number, list: ReadonlyArray<T>): { [index: string]: number };\n    countBy<T>(fn: (a: T) => string | number): (list: ReadonlyArray<T>) => { [index: string]: number };\n\n    /**\n     * Returns a curried equivalent of the provided function. The curried function has two unusual capabilities.\n     * First, its arguments needn't be provided one at a time.\n     */\n    curry<F extends (...args: any) => any>(f: F): Curry.Curry<F>;\n\n    /**\n     * Returns a curried equivalent of the provided function, with the specified arity. The curried function has\n     * two unusual capabilities. First, its arguments needn't be provided one at a time.\n     */\n    curryN(length: number, fn: (...args: any[]) => any): (...a: any[]) => any;\n\n    /**\n     * Decrements its argument.\n     */\n    dec(n: number): number;\n\n    /**\n     * Returns the second argument if it is not null or undefined. If it is null or undefined, the\n     * first (default) argument is returned.\n     */\n    defaultTo<T, U>(a: T, b: U | null | undefined): T | U;\n    defaultTo<T>(a: T): <U>(b: U | null | undefined) => T | U;\n\n    /**\n     * Makes a descending comparator function out of a function that returns a value that can be compared with < and >.\n     */\n    descend<T>(fn: (obj: T) => any, a: T, b: T): number;\n    descend<T>(fn: (obj: T) => any): (a: T, b: T) => number;\n\n    /**\n     * Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.\n     */\n    difference<T>(list1: ReadonlyArray<T>, list2: ReadonlyArray<T>): T[];\n    difference<T>(list1: ReadonlyArray<T>): (list2: ReadonlyArray<T>) => T[];\n\n    /**\n     * Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.\n     * Duplication is determined according to the value returned by applying the supplied predicate to two list\n     * elements.\n     */\n    differenceWith<T1, T2>(pred: (a: T1, b: T2) => boolean, list1: ReadonlyArray<T1>, list2: ReadonlyArray<T2>): T1[];\n    differenceWith<T1, T2>(pred: (a: T1, b: T2) => boolean): (list1: ReadonlyArray<T1>, list2: ReadonlyArray<T2>) => T1[];\n    differenceWith<T1, T2>(pred: (a: T1, b: T2) => boolean, list1: ReadonlyArray<T1>): (list2: ReadonlyArray<T2>) => T1[];\n\n    /*\n     * Returns a new object that does not contain a prop property.\n     */\n    // It seems impossible to infer the return type, so this may to be specified explicitely\n    dissoc<T>(prop: string, obj: any): T;\n    dissoc(prop: string): <U>(obj: any) => U;\n\n    /**\n     * Makes a shallow clone of an object, omitting the property at the given path.\n     */\n    dissocPath<T>(path: Path, obj: any): T;\n    dissocPath<T>(path: Path): (obj: any) => T;\n\n    /**\n     * Divides two numbers. Equivalent to a / b.\n     */\n    divide(__: Placeholder, b: number): (a: number) => number;\n    divide(__: Placeholder): (b: number, a: number) => number;\n    divide(a: number, b: number): number;\n    divide(a: number): (b: number) => number;\n\n    /**\n     * Returns a new list containing all but the first n elements of the given list.\n     */\n    drop<T>(n: number, xs: ReadonlyArray<T>): T[];\n    drop(n: number, xs: string): string;\n    drop<T>(n: number): {\n      (xs: string): string;\n      (xs: ReadonlyArray<T>): T[];\n    };\n\n    /**\n     * Returns a list containing all but the last n elements of the given list.\n     */\n    dropLast<T>(n: number, xs: ReadonlyArray<T>): T[];\n    dropLast(n: number, xs: string): string;\n    dropLast<T>(n: number): {\n      (xs: ReadonlyArray<T>): T[];\n      (xs: string): string;\n    };\n\n    /**\n     * Returns a new list containing all but last then elements of a given list, passing each value from the\n     * right to the supplied predicate function, skipping elements while the predicate function returns true.\n     */\n    dropLastWhile<T>(fn: (a: T) => boolean, list: ReadonlyArray<T>): T[];\n    dropLastWhile<T>(fn: (a: T) => boolean): (list: ReadonlyArray<T>) => T[];\n\n    /**\n     * Returns a new list containing the last n elements of a given list, passing each value to the supplied\n     * predicate function, skipping elements while the predicate function returns true.\n     */\n    dropWhile<T>(fn: (a: T) => boolean, list: ReadonlyArray<T>): T[];\n    dropWhile<T>(fn: (a: T) => boolean): (list: ReadonlyArray<T>) => T[];\n\n    /**\n     * A function wrapping calls to the two functions in an || operation, returning the result of the first\n     * function if it is truth-y and the result of the second function otherwise. Note that this is\n     * short-circuited, meaning that the second function will not be invoked if the first returns a truth-y value.\n     */\n    either(pred1: Pred, pred2: Pred): Pred;\n    either(pred1: Pred): (pred2: Pred) => Pred;\n\n    /**\n     * Returns the empty value of its argument's type. Ramda defines the empty value of Array ([]), Object ({}),\n     * String (''), and Arguments. Other types are supported if they define <Type>.empty and/or <Type>.prototype.empty.\n     * Dispatches to the empty method of the first argument, if present.\n     */\n    empty<T>(x: T): T;\n\n    /**\n     * Checks if a list ends with the provided values\n     */\n    endsWith(a: string, list: string): boolean;\n    endsWith(a: string): (list: string) => boolean;\n    endsWith<T>(a: T | ReadonlyArray<T>, list: ReadonlyArray<T>): boolean;\n    endsWith<T>(a: T | ReadonlyArray<T>): (list: ReadonlyArray<T>) => boolean;\n\n    /**\n     * Takes a function and two values in its domain and returns true if the values map to the same value in the\n     * codomain; false otherwise.\n     */\n    eqBy<T, U = T>(fn: (a: T) => U, a: T, b: T): boolean;\n    eqBy<T, U = T>(fn: (a: T) => U, a: T): (b: T) => boolean;\n    eqBy<T, U = T>(fn: (a: T) => U): Curry.Curry<(a: T, b: T) => boolean>;\n\n    /**\n     * Reports whether two functions have the same value for the specified property.\n     */\n    eqProps<T, U>(prop: string, obj1: T, obj2: U): boolean;\n    eqProps<P extends string>(prop: P): <T, U>(obj1: Record<P, T>, obj2: Record<P, U>) => boolean;\n    eqProps<T>(prop: string, obj1: T): <U>(obj2: U) => boolean;\n\n    /**\n     * Returns true if its arguments are equivalent, false otherwise. Dispatches to an equals method if present.\n     * Handles cyclical data structures.\n     */\n    equals<T>(a: T, b: T): boolean;\n    equals<T>(a: T): (b: T) => boolean;\n\n    /**\n     * Creates a new object by evolving a shallow copy of object, according to the transformation functions.\n     */\n    evolve<E extends Evolver, V extends Evolvable<E>>(transformations: E, obj: V): Evolve<V, E>;\n    evolve<E extends Evolver>(transformations: E): <V extends Evolvable<E>>(obj: V) => Evolve<V, E>;\n\n    /*\n     * A function that always returns false. Any passed in parameters are ignored.\n     */\n    F(): boolean;\n\n    /**\n     * Returns a new list containing only those items that match a given predicate function. The predicate function is passed one argument: (value).\n     */\n    filter: Filter;\n\n    /**\n     * Returns the first element of the list which matches the predicate, or undefined if no\n     * element matches.\n     */\n    find<T>(fn: (a: T) => boolean, list: ReadonlyArray<T>): T | undefined;\n    find<T>(fn: (a: T) => boolean): (list: ReadonlyArray<T>) => T | undefined;\n\n    /**\n     * Returns the index of the first element of the list which matches the predicate, or -1\n     * if no element matches.\n     */\n    findIndex<T>(fn: (a: T) => boolean, list: ReadonlyArray<T>): number;\n    findIndex<T>(fn: (a: T) => boolean): (list: ReadonlyArray<T>) => number;\n\n    /**\n     * Returns the last element of the list which matches the predicate, or undefined if no\n     * element matches.\n     */\n    findLast<T>(fn: (a: T) => boolean, list: ReadonlyArray<T>): T | undefined;\n    findLast<T>(fn: (a: T) => boolean): (list: ReadonlyArray<T>) => T | undefined;\n\n    /**\n     * Returns the index of the last element of the list which matches the predicate, or\n     * -1 if no element matches.\n     */\n    findLastIndex<T>(fn: (a: T) => boolean, list: ReadonlyArray<T>): number;\n    findLastIndex<T>(fn: (a: T) => boolean): (list: ReadonlyArray<T>) => number;\n\n    /**\n     * Returns a new list by pulling every item out of it (and all its sub-arrays) and putting\n     * them in a new array, depth-first.\n     */\n    flatten<T>(x: ReadonlyArray<T> | ReadonlyArray<T[]> | ReadonlyArray<ReadonlyArray<T>>): T[];\n\n    /**\n     * Returns a new function much like the supplied one, except that the first two arguments'\n     * order is reversed.\n     */\n    flip<T, U, TResult>(fn: (arg0: T, arg1: U) => TResult): (arg1: U, arg0?: T) => TResult;\n    flip<T, U, TResult>(fn: (arg0: T, arg1: U, ...args: any[]) => TResult): (arg1: U, arg0?: T, ...args: any[]) => TResult;\n\n    /**\n     * Iterate over an input list, calling a provided function fn for each element in the list.\n     */\n    forEach<T>(fn: (x: T) => void, list: T[]): T[];\n    forEach<T>(fn: (x: T) => void): (list: T[]) => T[];\n    forEach<T>(fn: (x: T) => void, list: ReadonlyArray<T>): ReadonlyArray<T>;\n    forEach<T>(fn: (x: T) => void): (list: ReadonlyArray<T>) => ReadonlyArray<T>;\n\n    /**\n     * Iterate over an input object, calling a provided function fn for each key and value in the object.\n     */\n    forEachObjIndexed<T>(fn: (value: T[keyof T], key: keyof T, obj: T) => void, obj: T): T;\n    forEachObjIndexed<T>(fn: (value: T[keyof T], key: keyof T, obj: T) => void): (obj: T) => T;\n\n    /**\n     * Creates a new object out of a list key-value pairs.\n     */\n    fromPairs<V>(pairs: Array<KeyValuePair<string, V>>): { [index: string]: V };\n    fromPairs<V>(pairs: Array<KeyValuePair<number, V>>): { [index: number]: V };\n\n    /**\n     * Splits a list into sublists stored in an object, based on the result of\n     * calling a String-returning function\n     * on each element, and grouping the results according to values returned.\n     */\n    groupBy<T>(fn: (a: T) => string, list: ReadonlyArray<T>): { [index: string]: T[] };\n    groupBy<T>(fn: (a: T) => string): (list: ReadonlyArray<T>) => { [index: string]: T[] };\n\n    /**\n     * Takes a list and returns a list of lists where each sublist's elements are all \"equal\" according to the provided equality function\n     */\n    groupWith<T>(fn: (x: T, y: T) => boolean): (list: ReadonlyArray<T>) => T[][];\n    groupWith<T>(fn: (x: T, y: T) => boolean, list: ReadonlyArray<T>): T[][];\n    groupWith<T>(fn: (x: T, y: T) => boolean, list: string): string[];\n\n    /**\n     * Returns true if the first parameter is greater than the second.\n     */\n    gt(__: Placeholder, b: number): (a: number) => boolean;\n    gt(__: Placeholder): (b: number, a: number) => boolean;\n    gt(a: number, b: number): boolean;\n    gt(a: number): (b: number) => boolean;\n\n    /**\n     * Returns true if the first parameter is greater than or equal to the second.\n     */\n    gte(__: Placeholder, b: number): (a: number) => boolean;\n    gte(__: Placeholder): (b: number, a: number) => boolean;\n    gte(a: number, b: number): boolean;\n    gte(a: number): (b: number) => boolean;\n\n    /**\n     * Returns whether or not an object has an own property with the specified name.\n     */\n    has<T>(__: Placeholder, obj: T): (s: string) => boolean;\n    has<T>(__: Placeholder): (obj: T, s: string) => boolean;\n    has<T>(s: string, obj: T): boolean;\n    has(s: string): <T>(obj: T) => boolean;\n\n    /**\n     * Returns whether or not an object or its prototype chain has a property with the specified name\n     */\n    hasIn<T>(s: string, obj: T): boolean;\n    hasIn(s: string): <T>(obj: T) => boolean;\n\n    /**\n     * Returns the first element in a list.\n     * In some libraries this function is named first.\n     */\n    head<T>(list: ReadonlyArray<T>): T | undefined;\n    head(list: string): string;\n\n    /**\n     * Returns true if its arguments are identical, false otherwise. Values are identical if they reference the\n     * same memory. NaN is identical to NaN; 0 and -0 are not identical.\n     */\n    identical<T>(a: T, b: T): boolean;\n    identical<T>(a: T): (b: T) => boolean;\n\n    /**\n     * A function that does nothing but return the parameter supplied to it. Good as a default\n     * or placeholder function.\n     */\n    identity<T>(a: T): T;\n\n    /**\n     * Creates a function that will process either the onTrue or the onFalse function depending upon the result\n     * of the condition predicate.\n     */\n    ifElse(fn: Pred, onTrue: Arity1Fn, onFalse: Arity1Fn): Arity1Fn;\n    ifElse(fn: Pred, onTrue: Arity2Fn, onFalse: Arity2Fn): Arity2Fn;\n\n    /**\n     * Increments its argument.\n     */\n    inc(n: number): number;\n\n    /**\n     * Given a target, this function checks a list for the target and returns a boolean.\n     * Given a string, this function checks for the string in another string or list and returns\n     * a boolean.\n     */\n    includes(s: string, list: ReadonlyArray<string> | string): boolean;\n    includes(s: string): (list: ReadonlyArray<string> | string)  => boolean;\n    includes<T>(target: T, list: ReadonlyArray<T>): boolean;\n    includes<T>(target: T): (list: ReadonlyArray<T>) => boolean;\n\n    /**\n     * Given a function that generates a key, turns a list of objects into an object indexing the objects\n     * by the given key.\n     */\n    indexBy<T>(fn: (a: T) => string, list: ReadonlyArray<T>): { [key: string]: T };\n    indexBy<T>(fn: (a: T) => string): (list: ReadonlyArray<T>) => { [key: string]: T };\n\n    /**\n     * Returns the position of the first occurrence of an item in an array\n     * (by strict equality),\n     * or -1 if the item is not included in the array.\n     */\n    indexOf<T>(target: T, list: ReadonlyArray<T>): number;\n    indexOf<T>(target: T): (list: ReadonlyArray<T>) => number;\n\n    /**\n     * Returns all but the last element of a list or string.\n     */\n    init<T>(list: ReadonlyArray<T>): T[];\n    init(list: string): string;\n\n    /**\n     * Takes a predicate pred, a list xs, and a list ys, and returns a list\n     * xs' comprising each of the elements of xs which is equal to one or more\n     * elements of ys according to pred.\n     *\n     * pred must be a binary function expecting an element from each list.\n     *\n     * xs, ys, and xs' are treated as sets, semantically, so ordering should\n     * not be significant, but since xs' is ordered the implementation guarantees\n     * that its values are in the same order as they appear in xs. Duplicates are\n     * not removed, so xs' may contain duplicates if xs contains duplicates.\n     */\n\n    innerJoin<T1, T2>(pred: (a: T1, b: T2) => boolean, list1: ReadonlyArray<T1>, list2: ReadonlyArray<T2>): T1[];\n    innerJoin<T1, T2>(pred: (a: T1, b: T2) => boolean): (list1: ReadonlyArray<T1>, list2: ReadonlyArray<T2>) => T1[];\n    innerJoin<T1, T2>(pred: (a: T1, b: T2) => boolean, list1: ReadonlyArray<T1>): (list2: ReadonlyArray<T2>) => T1[];\n\n    /**\n     * Inserts the supplied element into the list, at index index. Note that\n     * this is not destructive: it returns a copy of the list with the changes.\n     */\n    insert<T>(index: number, elt: T, list: ReadonlyArray<T>): T[];\n    insert<T>(index: number, elt: T): (list: ReadonlyArray<T>) => T[];\n    insert(index: number): <T>(elt: T, list: ReadonlyArray<T>) => T[];\n\n    /**\n     * Inserts the sub-list into the list, at index index.  _Note  that this\n     * is not destructive_: it returns a copy of the list with the changes.\n     */\n    insertAll<T>(index: number, elts: ReadonlyArray<T>, list: ReadonlyArray<T>): T[];\n    insertAll<T>(index: number, elts: ReadonlyArray<T>): (list: ReadonlyArray<T>) => T[];\n    insertAll(index: number): <T>(elts: ReadonlyArray<T>, list: ReadonlyArray<T>) => T[];\n\n    /**\n     * Combines two lists into a set (i.e. no duplicates) composed of those elements common to both lists.\n     */\n    intersection<T>(list1: ReadonlyArray<T>, list2: ReadonlyArray<T>): T[];\n    intersection<T>(list1: ReadonlyArray<T>): (list2: ReadonlyArray<T>) => T[];\n\n    /**\n     * Combines two lists into a set (i.e. no duplicates) composed of those\n     * elements common to both lists.  Duplication is determined according\n     * to the value returned by applying the supplied predicate to two list\n     * elements.\n     */\n    intersectionWith<T>(pred: (a: T, b: T) => boolean, list1: ReadonlyArray<T>, list2: ReadonlyArray<T>): T[];\n\n    /**\n     * Creates a new list with the separator interposed between elements.\n     */\n    intersperse<T>(separator: T, list: ReadonlyArray<T>): T[];\n    intersperse<T>(separator: T): (list: ReadonlyArray<T>) => T[];\n\n    /**\n     * Transforms the items of the list with the transducer and appends the transformed items to the accumulator\n     * using an appropriate iterator function based on the accumulator type.\n     */\n    into<T>(acc: any, xf: (...a: any[]) => any, list: ReadonlyArray<T>): T[];\n    into(acc: any, xf: (...a: any[]) => any): <T>(list: ReadonlyArray<T>) => T[];\n    into(acc: any): <T>(xf: (...a: any[]) => any, list: ReadonlyArray<T>) => T[];\n\n    /**\n     * Same as R.invertObj, however this accounts for objects with duplicate values by putting the values into an array.\n     */\n    invert<T>(obj: T): { [index: string]: string[] };\n\n    /**\n     * Returns a new object with the keys of the given object as values, and the values of the given object as keys.\n     */\n    invertObj(obj: { [index: string]: string } | { [index: number]: string }): { [index: string]: string };\n\n    /**\n     * Turns a named method with a specified arity into a function that can be called directly\n     * supplied with arguments and a target object.\n     *\n     * The returned function is curried and accepts arity + 1 parameters where the final\n     * parameter is the target object.\n     */\n    invoker(arity: number, method: string): (...a: any[]) => any;\n\n    /**\n     * See if an object (val) is an instance of the supplied constructor.\n     * This function will check up the inheritance chain, if any.\n     */\n    is(ctor: any, val: any): boolean;\n    is(ctor: any): (val: any) => boolean;\n\n    /**\n     * Tests whether or not an object is similar to an array.\n     */\n    isArrayLike(val: any): boolean;\n\n    /**\n     * Reports whether the list has zero elements.\n     */\n    isEmpty(value: any): boolean;\n\n    /**\n     * Returns true if the input value is NaN.\n     */\n    isNaN(x: any): boolean;\n\n    /**\n     * Checks if the input value is null or undefined.\n     */\n    isNil(value: any): value is null | undefined;\n\n    /**\n     * Returns a string made by inserting the separator between each\n     * element and concatenating all the elements into a single string.\n     */\n    join(x: string, xs: ReadonlyArray<any>): string;\n    join(x: string): (xs: ReadonlyArray<any>) => string;\n\n    /**\n     * Applies a list of functions to a list of values.\n     */\n    juxt<T, U>(fns: Array<(...args: T[]) => U>): (...args: T[]) => U[];\n\n    /**\n     * Returns a list containing the names of all the enumerable own\n     * properties of the supplied object.\n     */\n    keys<T extends object>(x: T): Array<keyof T>;\n    keys<T>(x: T): string[];\n\n    /**\n     * Returns a list containing the names of all the\n     * properties of the supplied object, including prototype properties.\n     */\n    keysIn<T>(obj: T): string[];\n\n    /**\n     * Returns the last element from a list.\n     */\n    last<T>(list: ReadonlyArray<T>): T | undefined;\n    last(list: string): string;\n\n    /**\n     * Returns the position of the last occurrence of an item (by strict equality) in\n     * an array, or -1 if the item is not included in the array.\n     */\n    lastIndexOf<T>(target: T, list: ReadonlyArray<T>): number;\n\n    /**\n     * Returns the number of elements in the array by returning list.length.\n     */\n    length<T>(list: ReadonlyArray<T>): number;\n\n    /**\n     * Returns a lens for the given getter and setter functions. The getter\n     * \"gets\" the value of the focus; the setter \"sets\" the value of the focus.\n     * The setter should not mutate the data structure.\n     */\n    lens<T, U, V>(getter: (s: T) => U, setter: (a: U, s: T) => V): Lens;\n\n    /**\n     * Creates a lens that will focus on index n of the source array.\n     */\n    lensIndex(n: number): Lens;\n\n    /**\n     * Returns a lens whose focus is the specified path.\n     * See also view, set, over.\n     */\n    lensPath(path: Path): Lens;\n\n    /**\n     * lensProp creates a lens that will focus on property k of the source object.\n     */\n    lensProp(str: string): {\n      <T, U>(obj: T): U;\n      set<T, U, V>(val: T, obj: U): V;\n      /*map<T>(fn: (...a: any[]) => any, obj: T): T*/\n    };\n\n    /**\n     * \"lifts\" a function of arity > 1 so that it may \"map over\" a list, Function or other object that satisfies\n     * the FantasyLand Apply spec.\n     */\n    lift(fn: ((...a: any[]) => any), ...args: any[]): any;\n\n    /**\n     * \"lifts\" a function to be the specified arity, so that it may \"map over\" that many lists, Functions or other\n     * objects that satisfy the FantasyLand Apply spec.\n     */\n    liftN(n: number, fn: ((...a: any[]) => any), ...args: any[]): any;\n\n    /**\n     * Returns true if the first parameter is less than the second.\n     */\n    lt(__: Placeholder, b: number): (a: number) => boolean;\n    lt(__: Placeholder): (b: number, a: number) => boolean;\n    lt(a: number, b: number): boolean;\n    lt(a: number): (b: number) => boolean;\n\n    /**\n     * Returns true if the first parameter is less than or equal to the second.\n     */\n    lte(__: Placeholder, b: number): (a: number) => boolean;\n    lte(__: Placeholder): (b: number, a: number) => boolean;\n    lte(a: number, b: number): boolean;\n    lte(a: number): (b: number) => boolean;\n\n    /**\n     * Returns a new list, constructed by applying the supplied function to every element of the supplied list.\n     */\n    map<T, U>(fn: (x: T) => U, list: ReadonlyArray<T>): U[];\n    map<T, U>(fn: (x: T) => U): (list: ReadonlyArray<T>) => U[];\n    map<T, U>(fn: (x: T[keyof T & keyof U]) => U[keyof T & keyof U], list: T): U;\n    map<T, U>(fn: (x: T[keyof T & keyof U]) => U[keyof T & keyof U]): (list: T) => U;\n    map<T, U>(fn: (x: T) => U, obj: Functor<T>): Functor<U>; // used in functors\n    map<T, U>(fn: (x: T) => U): (obj: Functor<T>) => Functor<U>; // used in functors\n\n    /**\n     * The mapAccum function behaves like a combination of map and reduce.\n     */\n    mapAccum<T, U, TResult>(fn: (acc: U, value: T) => [U, TResult], acc: U, list: ReadonlyArray<T>): [U, TResult[]];\n    mapAccum<T, U, TResult>(fn: (acc: U, value: T) => [U, TResult]): (acc: U, list: ReadonlyArray<T>) => [U, TResult[]];\n    mapAccum<T, U, TResult>(fn: (acc: U, value: T) => [U, TResult], acc: U): (list: ReadonlyArray<T>) => [U, TResult[]];\n\n    /**\n     * The mapAccumRight function behaves like a combination of map and reduce.\n     */\n    mapAccumRight<T, U, TResult>(fn: (acc: U, value: T) => [U, TResult], acc: U, list: ReadonlyArray<T>): [U, TResult[]];\n    mapAccumRight<T, U, TResult>(fn: (acc: U, value: T) => [U, TResult]): (acc: U, list: ReadonlyArray<T>) => [U, TResult[]];\n    mapAccumRight<T, U, TResult>(fn: (acc: U, value: T) => [U, TResult], acc: U): (list: ReadonlyArray<T>) => [U, TResult[]];\n\n    /**\n     * Like mapObj, but but passes additional arguments to the predicate function.\n     */\n    mapObjIndexed<T, TResult>(\n      fn: (value: T, key: string, obj?: {\n        [key: string]: T\n      }) => TResult,\n      obj: {\n        [key: string]: T\n      }\n    ): {\n      [key: string]: TResult\n    };\n    mapObjIndexed<T, TResult>(fn: (value: T, key: string, obj?: any) => TResult, obj: any): { [index: string]: TResult };\n    mapObjIndexed<T, TResult>(fn: (value: T, key: string, obj?: any) => TResult): (obj: any) => { [index: string]: TResult };\n\n    /**\n     * Tests a regular expression agains a String\n     */\n    match(regexp: RegExp, str: string): any[];\n    match(regexp: RegExp): (str: string) => any[];\n\n    /**\n     * mathMod behaves like the modulo operator should mathematically, unlike the %\n     * operator (and by extension, R.modulo). So while \"-17 % 5\" is -2,\n     * mathMod(-17, 5) is 3. mathMod requires Integer arguments, and returns NaN\n     * when the modulus is zero or negative.\n     */\n    mathMod(__: Placeholder, b: number): (a: number) => number;\n    mathMod(__: Placeholder): (b: number, a: number) => number;\n    mathMod(a: number, b: number): number;\n    mathMod(a: number): (b: number) => number;\n\n    /**\n     * Returns the larger of its two arguments.\n     */\n    max<T extends Ord>(a: T, b: T): T;\n    max<T extends Ord>(a: T): (b: T) => T;\n\n    /**\n     * Takes a function and two values, and returns whichever value produces\n     * the larger result when passed to the provided function.\n     */\n    maxBy<T>(keyFn: (a: T) => Ord, a: T, b: T): T;\n    maxBy<T>(keyFn: (a: T) => Ord, a: T): (b: T) => T;\n    maxBy<T>(keyFn: (a: T) => Ord): Curry.Curry<(a: T, b: T) => T>;\n\n    /**\n     * Returns the mean of the given list of numbers.\n     */\n    mean(list: ReadonlyArray<number>): number;\n\n    /**\n     * Returns the median of the given list of numbers.\n     */\n    median(list: ReadonlyArray<number>): number;\n\n    /**\n     * @deprecated since v0.25.0\n     *\n     * Creates a new function that, when invoked, caches the result of calling fn for a given argument set and\n     * returns the result. Subsequent calls to the memoized fn with the same argument set will not result in an\n     * additional call to fn; instead, the cached result for that set of arguments will be returned.\n     */\n    memoize<T extends (...args: any[]) => any>(fn: T): T;\n\n    /**\n     * A customisable version of R.memoize. memoizeWith takes an additional function that will be applied to a given\n     * argument set and used to create the cache key under which the results of the function to be memoized will be stored.\n     * Care must be taken when implementing key generation to avoid clashes that may overwrite previous entries erroneously.\n     */\n    memoizeWith<T extends (...args: any[]) => any>(keyFn: (...v: any[]) => string, fn: T): T;\n\n    /**\n     * Create a new object with the own properties of a\n     * merged with the own properties of object b.\n     * This function will *not* mutate passed-in objects.\n     */\n    merge<T2>(__: Placeholder, b: T2): <T1>(a: T1) => T1 & T2;\n    merge(__: Placeholder): <T1, T2>(b: T2, a: T1) => T1 & T2;\n    merge<T1, T2>(a: T1, b: T2): T1 & T2;\n    merge<T1>(a: T1): <T2>(b: T2) => T1 & T2;\n\n    /**\n     * Merges a list of objects together into one object.\n     */\n    mergeAll<T>(list: ReadonlyArray<any>): T;\n\n    /**\n     * Creates a new object with the own properties of the first object merged with the own properties of the second object.\n     * If a key exists in both objects:\n     * and both values are objects, the two values will be recursively merged\n     * otherwise the value from the first object will be used.\n     */\n    mergeDeepLeft<T1, T2>(a: T1, b: T2): T1 & T2;\n    mergeDeepLeft<T1>(a: T1): <T2>(b: T2) => T1 & T2;\n\n    /**\n     * Creates a new object with the own properties of the first object merged with the own properties of the second object.\n     * If a key exists in both objects:\n     * and both values are objects, the two values will be recursively merged\n     * otherwise the value from the second object will be used.\n     */\n    mergeDeepRight<A, B>(a: A, b: B): A & B;\n    mergeDeepRight<A>(a: A): <B>(b: B) => A & B;\n\n    /**\n     * Creates a new object with the own properties of the two provided objects. If a key exists in both objects:\n     * and both associated values are also objects then the values will be recursively merged.\n     * otherwise the provided function is applied to associated values using the resulting value as the new value\n     * associated with the key. If a key only exists in one object, the value will be associated with the key of the resulting object.\n     */\n    mergeDeepWith<T1, T2>(fn: (x: any, z: any) => any, a: T1, b: T2): T1 & T2;\n    mergeDeepWith<T1, T2>(fn: (x: any, z: any) => any, a: T1): (b: T2) => T1 & T2;\n    mergeDeepWith<T1, T2>(fn: (x: any, z: any) => any): (a: T1, b: T2) => T1 & T2;\n\n    /**\n     * Creates a new object with the own properties of the two provided objects. If a key exists in both objects:\n     * and both associated values are also objects then the values will be recursively merged.\n     * otherwise the provided function is applied to the key and associated values using the resulting value as\n     * the new value associated with the key. If a key only exists in one object, the value will be associated with\n     * the key of the resulting object.\n     */\n    mergeDeepWithKey<T1, T2>(fn: (k: string, x: any, z: any) => any, a: T1, b: T2): T1 & T2;\n    mergeDeepWithKey<T1, T2>(fn: (k: string, x: any, z: any) => any, a: T1): (b: T2) => T1 & T2;\n    mergeDeepWithKey<T1, T2>(fn: (k: string, x: any, z: any) => any): (a: T1, b: T2) => T1 & T2;\n\n    /**\n     * Creates a new object with the own properties of the two provided objects. If a key exists in both objects,\n     * the provided function is applied to the values associated with the key in each object, with the result being used as\n     * the value associated with the key in the returned object. The key will be excluded from the returned object if the\n     * resulting value is undefined.\n     */\n    mergeWith<U, V>(fn: (x: any, z: any) => any, a: U, b: V): U & V;\n    mergeWith<U>(fn: (x: any, z: any) => any, a: U): <V>(b: V) => U & V;\n    mergeWith(fn: (x: any, z: any) => any): <U, V>(a: U, b: V) => U & V;\n\n    /**\n     * Creates a new object with the own properties of the two provided objects. If a key exists in both objects,\n     * the provided function is applied to the key and the values associated with the key in each object, with the\n     * result being used as the value associated with the key in the returned object. The key will be excluded from\n     * the returned object if the resulting value is undefined.\n     */\n    mergeWithKey<U, V>(fn: (str: string, x: any, z: any) => any, a: U, b: V): U & V;\n    mergeWithKey<U>(fn: (str: string, x: any, z: any) => any, a: U): <V>(b: V) => U & V;\n    mergeWithKey(fn: (str: string, x: any, z: any) => any): <U, V>(a: U, b: V) => U & V;\n\n    /**\n     * Returns the smaller of its two arguments.\n     */\n    min<T extends Ord>(a: T, b: T): T;\n    min<T extends Ord>(a: T): (b: T) => T;\n\n    /**\n     * Takes a function and two values, and returns whichever value produces\n     * the smaller result when passed to the provided function.\n     */\n    minBy<T>(keyFn: (a: T) => Ord, a: T, b: T): T;\n    minBy<T>(keyFn: (a: T) => Ord, a: T): (b: T) => T;\n    minBy<T>(keyFn: (a: T) => Ord): Curry.Curry<(a: T, b: T) => T>;\n\n    /**\n     * Divides the second parameter by the first and returns the remainder.\n     * The flipped version (moduloBy) may be more useful curried.\n     * Note that this functions preserves the JavaScript-style behavior for\n     * modulo. For mathematical modulo see mathMod\n     */\n    modulo(__: Placeholder, b: number): (a: number) => number;\n    modulo(__: Placeholder): (b: number, a: number) => number;\n    modulo(a: number, b: number): number;\n    modulo(a: number): (b: number) => number;\n\n    /**\n     * Multiplies two numbers. Equivalent to a * b but curried.\n     */\n    multiply(a: number, b: number): number;\n    multiply(a: number): (b: number) => number;\n\n    /**\n     * Moves an item, at index from, to index to, in a list of elements.\n     * A new list will be created containing the new elements order.\n     */\n    move<T>(from: number, to: number, list: ReadonlyArray<T>): T[];\n    move(from: number, to: number): <T>(list: ReadonlyArray<T>) => T[];\n    move(from: number): {\n      <T>(to: number, list: ReadonlyArray<T>): T[];\n      (to: number): <T>(list: ReadonlyArray<T>) => T[];\n    };\n\n    /**\n     * Wraps a function of any arity (including nullary) in a function that accepts exactly n parameters.\n     * Any extraneous parameters will not be passed to the supplied function.\n     */\n    nAry(n: number, fn: (...arg: any[]) => any): (...a: any[]) => any;\n    nAry(n: number): (fn: (...arg: any[]) => any) => (...a: any[]) => any;\n\n    /**\n     * Negates its argument.\n     */\n    negate(n: number): number;\n\n    /**\n     * Returns true if no elements of the list match the predicate, false otherwise.\n     */\n    none<T>(fn: (a: T) => boolean, list: ReadonlyArray<T>): boolean;\n    none<T>(fn: (a: T) => boolean): (list: ReadonlyArray<T>) => boolean;\n\n    /**\n     * A function wrapping a call to the given function in a ! operation.  It will return true when the\n     * underlying function would return a false-y value, and false when it would return a truth-y one.\n     */\n    not(value: any): boolean;\n\n    /**\n     * Returns the nth element in a list.\n     */\n    nth<T>(n: number, list: ReadonlyArray<T>): T | undefined;\n    nth(n: number): <T>(list: ReadonlyArray<T>) => T | undefined;\n\n    /**\n     * Returns a function which returns its nth argument.\n     */\n    nthArg(n: number): (...a: any[]) => any;\n\n    /**\n     * Creates an object containing a single key:value pair.\n     */\n    objOf<T, K extends string>(key: K, value: T): Record<K, T>;\n    objOf<K extends string>(key: K): <T>(value: T) => Record<K, T>;\n\n    /**\n     * Returns a singleton array containing the value provided.\n     */\n    of<T>(x: T): T[];\n\n    /**\n     * Returns a partial copy of an object omitting the keys specified.\n     */\n    omit<T, K extends string>(names: ReadonlyArray<K>, obj: T): Omit<T, K>;\n    omit<K extends string>(names: ReadonlyArray<K>): <T>(obj: T) => Omit<T, K>;\n\n    /**\n     * Accepts a function fn and returns a function that guards invocation of fn such that fn can only ever be\n     * called once, no matter how many times the returned function is invoked. The first value calculated is\n     * returned in subsequent invocations.\n     */\n    once(fn: (...a: any[]) => any): (...a: any[]) => any;\n    once<T>(fn: (...a: any[]) => T): (...a: any[]) => T;\n\n    /**\n     * A function that returns the first truthy of two arguments otherwise the last argument. Note that this is\n     * NOT short-circuited, meaning that if expressions are passed they are both evaluated.\n     * Dispatches to the or method of the first argument if applicable.\n     */\n    or<T, U>(a: T, b: U): T | U;\n    or<T>(a: T): <U>(b: U) => T | U;\n    or<T extends { or?: ((...a: any[]) => any); }, U>(fn1: T, val2: U): T | U;\n    or<T extends { or?: ((...a: any[]) => any); }>(fn1: T): <U>(val2: U) => T | U;\n\n    /**\n     * Returns the result of \"setting\" the portion of the given data structure\n     * focused by the given lens to the given value.\n     */\n    over<T>(lens: Lens, fn: Arity1Fn, value: T): T;\n    over<T>(lens: Lens, fn: Arity1Fn, value: T[]): T[];\n    over(lens: Lens, fn: Arity1Fn): <T>(value: T) => T;\n    over(lens: Lens, fn: Arity1Fn): <T>(value: T[]) => T[];\n    over(lens: Lens): <T>(fn: Arity1Fn, value: T) => T;\n    over(lens: Lens): <T>(fn: Arity1Fn, value: T[]) => T[];\n\n    /**\n     * Takes two arguments, fst and snd, and returns [fst, snd].\n     */\n    pair<F, S>(fst: F, snd: S): [F, S];\n\n    /**\n     * Takes a function f and a list of arguments, and returns a function g.\n     * When applied, g returns the result of applying f to the arguments\n     * provided initially followed by the arguments provided to g.\n     */\n    partial<V0, V1, T>(fn: (x0: V0, x1: V1) => T, args: [V0]): (x1: V1) => T;\n\n    partial<V0, V1, V2, T>(fn: (x0: V0, x1: V1, x2: V2) => T, args: [V0, V1]): (x2: V2) => T;\n    partial<V0, V1, V2, T>(fn: (x0: V0, x1: V1, x2: V2) => T, args: [V0]): (x1: V1, x2: V2) => T;\n\n    partial<V0, V1, V2, V3, T>(fn: (x0: V0, x1: V1, x2: V2, x3: V3) => T, args: [V0, V1, V2]): (x2: V3) => T;\n    partial<V0, V1, V2, V3, T>(fn: (x0: V0, x1: V1, x2: V2, x3: V3) => T, args: [V0, V1]): (x2: V2, x3: V3) => T;\n    partial<V0, V1, V2, V3, T>(fn: (x0: V0, x1: V1, x2: V2, x3: V3) => T, args: [V0]): (x1: V1, x2: V2, x3: V3) => T;\n\n    partial<T>(fn: (...a: any[]) => T, args: any[]): (...a: any[]) => T;\n\n    /**\n     * Takes a function f and a list of arguments, and returns a function g.\n     * When applied, g returns the result of applying f to the arguments\n     * provided to g followed by the arguments provided initially.\n     */\n    partialRight<V0, V1, T>(fn: (x0: V0, x1: V1) => T, args: [V1]): (x1: V0) => T;\n\n    partialRight<V0, V1, V2, T>(fn: (x0: V0, x1: V1, x2: V2) => T, args: [V1, V2]): (x2: V0) => T;\n    partialRight<V0, V1, V2, T>(fn: (x0: V0, x1: V1, x2: V2) => T, args: [V2]): (x1: V0, x2: V1) => T;\n\n    partialRight<V0, V1, V2, V3, T>(fn: (x0: V0, x1: V1, x2: V2, x3: V3) => T, args: [V1, V2, V3]): (x0: V0) => T;\n    partialRight<V0, V1, V2, V3, T>(fn: (x0: V0, x1: V1, x2: V2, x3: V3) => T, args: [V2, V3]): (x0: V0, x1: V1) => T;\n    partialRight<V0, V1, V2, V3, T>(fn: (x0: V0, x1: V1, x2: V2, x3: V3) => T, args: [V3]): (x0: V0, x1: V1, x2: V2) => T;\n\n    partialRight<T>(fn: (...a: any[]) => T, args: any[]): (...a: any[]) => T;\n\n    /**\n     * Takes a predicate and a list and returns the pair of lists of elements\n     * which do and do not satisfy the predicate, respectively.\n     */\n    partition(fn: (a: string) => boolean, list: ReadonlyArray<string>): [string[], string[]];\n    partition<T>(fn: (a: T) => boolean, list: ReadonlyArray<T>): [T[], T[]];\n    partition<T>(fn: (a: T) => boolean): (list: ReadonlyArray<T>) => [T[], T[]];\n    partition(fn: (a: string) => boolean): (list: ReadonlyArray<string>) => [string[], string[]];\n\n    /**\n     * Retrieve the value at a given path.\n     */\n    path<T>(path: Path, obj: any): T | undefined;\n    path<T>(path: Path): (obj: any) => T | undefined;\n\n    /**\n     * Determines whether a nested path on an object has a specific value,\n     * in R.equals terms. Most likely used to filter a list.\n     */\n    pathEq(path: Path, val: any, obj: any): boolean;\n    pathEq(path: Path, val: any): (obj: any) => boolean;\n    pathEq(path: Path): Curry.Curry<(a: any, b: any) => boolean>;\n\n    /**\n     * If the given, non-null object has a value at the given path, returns the value at that path.\n     * Otherwise returns the provided default value.\n     */\n    pathOr<T>(defaultValue: T, path: Path, obj: any): any;\n    pathOr<T>(defaultValue: T, path: Path): (obj: any) => any;\n    pathOr<T>(defaultValue: T): Curry.Curry<(a: Path, b: any) => any>;\n\n    /**\n     * Returns true if the specified object property at given path satisfies the given predicate; false otherwise.\n     */\n    pathSatisfies<T, U>(pred: (val: T) => boolean, path: Path, obj: U): boolean;\n    pathSatisfies<T, U>(pred: (val: T) => boolean, path: Path): (obj: U) => boolean;\n    pathSatisfies<T, U>(pred: (val: T) => boolean): Curry.Curry<(a: Path, b: U) => boolean>;\n\n    /**\n     * Returns a partial copy of an object containing only the keys specified.  If the key does not exist, the\n     * property is ignored.\n     */\n    pick<T, K extends string>(names: ReadonlyArray<K>, obj: T): Pick<T, Exclude<keyof T, Exclude<keyof T, K>>>;\n    pick<K extends string>(names: ReadonlyArray<K>): <T>(obj: T) => Pick<T, Exclude<keyof T, Exclude<keyof T, K>>>;\n\n    /**\n     * Similar to pick except that this one includes a key: undefined pair for properties that don't exist.\n     */\n    pickAll<T, U>(names: ReadonlyArray<string>, obj: T): U;\n    pickAll(names: ReadonlyArray<string>): <T, U>(obj: T) => U;\n\n    /**\n     * Returns a partial copy of an object containing only the keys that satisfy the supplied predicate.\n     */\n    pickBy<T, U>(pred: ObjPred, obj: T): U;\n    pickBy(pred: ObjPred): <T, U>(obj: T) => U;\n\n    /**\n     * Creates a new function that runs each of the functions supplied as parameters in turn,\n     * passing the return value of each function invocation to the next function invocation,\n     * beginning with whatever arguments were passed to the initial invocation.\n     */\n    pipe<T1>(fn0: () => T1): () => T1;\n    pipe<V0, T1>(fn0: (x0: V0) => T1): (x0: V0) => T1;\n    pipe<V0, V1, T1>(fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T1;\n    pipe<V0, V1, V2, T1>(fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T1;\n\n    pipe<T1, T2>(fn0: () => T1, fn1: (x: T1) => T2): () => T2;\n    pipe<V0, T1, T2>(fn0: (x0: V0) => T1, fn1: (x: T1) => T2): (x0: V0) => T2;\n    pipe<V0, V1, T1, T2>(fn0: (x0: V0, x1: V1) => T1, fn1: (x: T1) => T2): (x0: V0, x1: V1) => T2;\n    pipe<V0, V1, V2, T1, T2>(fn0: (x0: V0, x1: V1, x2: V2) => T1, fn1: (x: T1) => T2): (x0: V0, x1: V1, x2: V2) => T2;\n\n    pipe<T1, T2, T3>(fn0: () => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3): () => T3;\n    pipe<V0, T1, T2, T3>(fn0: (x: V0) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3): (x: V0) => T3;\n    pipe<V0, V1, T1, T2, T3>(fn0: (x0: V0, x1: V1) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3): (x0: V0, x1: V1) => T3;\n    pipe<V0, V1, V2, T1, T2, T3>(fn0: (x0: V0, x1: V1, x2: V2) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3): (x0: V0, x1: V1, x2: V2) => T3;\n\n    pipe<T1, T2, T3, T4>(fn0: () => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4): () => T4;\n    pipe<V0, T1, T2, T3, T4>(fn0: (x: V0) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4): (x: V0) => T4;\n    pipe<V0, V1, T1, T2, T3, T4>(fn0: (x0: V0, x1: V1) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4): (x0: V0, x1: V1) => T4;\n    pipe<V0, V1, V2, T1, T2, T3, T4>(fn0: (x0: V0, x1: V1, x2: V2) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4): (x0: V0, x1: V1, x2: V2) => T4;\n\n    pipe<T1, T2, T3, T4, T5>(fn0: () => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5): () => T5;\n    pipe<V0, T1, T2, T3, T4, T5>(fn0: (x: V0) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5): (x: V0) => T5;\n    pipe<V0, V1, T1, T2, T3, T4, T5>(fn0: (x0: V0, x1: V1) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5): (x0: V0, x1: V1) => T5;\n    pipe<V0, V1, V2, T1, T2, T3, T4, T5>(fn0: (x0: V0, x1: V1, x2: V2) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5): (x0: V0, x1: V1, x2: V2) => T5;\n\n    pipe<T1, T2, T3, T4, T5, T6>(fn0: () => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5, fn5: (x: T5) => T6): () => T6;\n    pipe<V0, T1, T2, T3, T4, T5, T6>(fn0: (x: V0) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5, fn5: (x: T5) => T6): (x: V0) => T6;\n    pipe<V0, V1, T1, T2, T3, T4, T5, T6>(fn0: (x0: V0, x1: V1) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5, fn5: (x: T5) => T6): (x0: V0, x1: V1) => T6;\n    pipe<V0, V1, V2, T1, T2, T3, T4, T5, T6>(\n      fn0: (x0: V0, x1: V1, x2: V2) => T1,\n      fn1: (x: T1) => T2,\n      fn2: (x: T2) => T3,\n      fn3: (x: T3) => T4,\n      fn4: (x: T4) => T5,\n      fn5: (x: T5) => T6): (x0: V0, x1: V1, x2: V2) => T6;\n\n    pipe<T1, T2, T3, T4, T5, T6, T7>(\n      fn0: () => T1,\n      fn1: (x: T1) => T2,\n      fn2: (x: T2) => T3,\n      fn3: (x: T3) => T4,\n      fn4: (x: T4) => T5,\n      fn5: (x: T5) => T6,\n      fn: (x: T6) => T7): () => T7;\n    pipe<V0, T1, T2, T3, T4, T5, T6, T7>(\n      fn0: (x: V0) => T1,\n      fn1: (x: T1) => T2,\n      fn2: (x: T2) => T3,\n      fn3: (x: T3) => T4,\n      fn4: (x: T4) => T5,\n      fn5: (x: T5) => T6,\n      fn: (x: T6) => T7): (x: V0) => T7;\n    pipe<V0, V1, T1, T2, T3, T4, T5, T6, T7>(\n      fn0: (x0: V0, x1: V1) => T1,\n      fn1: (x: T1) => T2,\n      fn2: (x: T2) => T3,\n      fn3: (x: T3) => T4,\n      fn4: (x: T4) => T5,\n      fn5: (x: T5) => T6,\n      fn6: (x: T6) => T7): (x0: V0, x1: V1) => T7;\n    pipe<V0, V1, V2, T1, T2, T3, T4, T5, T6, T7>(\n      fn0: (x0: V0, x1: V1, x2: V2) => T1,\n      fn1: (x: T1) => T2,\n      fn2: (x: T2) => T3,\n      fn3: (x: T3) => T4,\n      fn4: (x: T4) => T5,\n      fn5: (x: T5) => T6,\n      fn6: (x: T6) => T7): (x0: V0, x1: V1, x2: V2) => T7;\n\n    pipe<T1, T2, T3, T4, T5, T6, T7, T8>(\n      fn0: () => T1,\n      fn1: (x: T1) => T2,\n      fn2: (x: T2) => T3,\n      fn3: (x: T3) => T4,\n      fn4: (x: T4) => T5,\n      fn5: (x: T5) => T6,\n      fn6: (x: T6) => T7,\n      fn: (x: T7) => T8): () => T8;\n    pipe<V0, T1, T2, T3, T4, T5, T6, T7, T8>(\n      fn0: (x: V0) => T1,\n      fn1: (x: T1) => T2,\n      fn2: (x: T2) => T3,\n      fn3: (x: T3) => T4,\n      fn4: (x: T4) => T5,\n      fn5: (x: T5) => T6,\n      fn6: (x: T6) => T7,\n      fn: (x: T7) => T8): (x: V0) => T8;\n    pipe<V0, V1, T1, T2, T3, T4, T5, T6, T7, T8>(\n      fn0: (x0: V0, x1: V1) => T1,\n      fn1: (x: T1) => T2,\n      fn2: (x: T2) => T3,\n      fn3: (x: T3) => T4,\n      fn4: (x: T4) => T5,\n      fn5: (x: T5) => T6,\n      fn6: (x: T6) => T7,\n      fn7: (x: T7) => T8): (x0: V0, x1: V1) => T8;\n    pipe<V0, V1, V2, T1, T2, T3, T4, T5, T6, T7, T8>(\n      fn0: (x0: V0, x1: V1, x2: V2) => T1,\n      fn1: (x: T1) => T2,\n      fn2: (x: T2) => T3,\n      fn3: (x: T3) => T4,\n      fn4: (x: T4) => T5,\n      fn5: (x: T5) => T6,\n      fn6: (x: T6) => T7,\n      fn7: (x: T7) => T8): (x0: V0, x1: V1, x2: V2) => T8;\n\n    pipe<T1, T2, T3, T4, T5, T6, T7, T8, T9>(\n      fn0: () => T1,\n      fn1: (x: T1) => T2,\n      fn2: (x: T2) => T3,\n      fn3: (x: T3) => T4,\n      fn4: (x: T4) => T5,\n      fn5: (x: T5) => T6,\n      fn6: (x: T6) => T7,\n      fn7: (x: T7) => T8,\n      fn8: (x: T8) => T9): () => T9;\n    pipe<V0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(\n      fn0: (x0: V0) => T1,\n      fn1: (x: T1) => T2,\n      fn2: (x: T2) => T3,\n      fn3: (x: T3) => T4,\n      fn4: (x: T4) => T5,\n      fn5: (x: T5) => T6,\n      fn6: (x: T6) => T7,\n      fn7: (x: T7) => T8,\n      fn8: (x: T8) => T9): (x0: V0) => T9;\n    pipe<V0, V1, T1, T2, T3, T4, T5, T6, T7, T8, T9>(\n      fn0: (x0: V0, x1: V1) => T1,\n      fn1: (x: T1) => T2,\n      fn2: (x: T2) => T3,\n      fn3: (x: T3) => T4,\n      fn4: (x: T4) => T5,\n      fn5: (x: T5) => T6,\n      fn6: (x: T6) => T7,\n      fn7: (x: T7) => T8,\n      fn8: (x: T8) => T9): (x0: V0, x1: V1) => T9;\n    pipe<V0, V1, V2, T1, T2, T3, T4, T5, T6, T7, T8, T9>(\n      fn0: (x0: V0, x1: V1, x2: V2) => T1,\n      fn1: (x: T1) => T2,\n      fn2: (x: T2) => T3,\n      fn3: (x: T3) => T4,\n      fn4: (x: T4) => T5,\n      fn5: (x: T5) => T6,\n      fn6: (x: T6) => T7,\n      fn7: (x: T7) => T8,\n      fn8: (x: T8) => T9): (x0: V0, x1: V1, x2: V2) => T9;\n\n    pipe<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(\n      fn0: () => T1,\n      fn1: (x: T1) => T2,\n      fn2: (x: T2) => T3,\n      fn3: (x: T3) => T4,\n      fn4: (x: T4) => T5,\n      fn5: (x: T5) => T6,\n      fn6: (x: T6) => T7,\n      fn7: (x: T7) => T8,\n      fn8: (x: T8) => T9,\n      fn9: (x: T9) => T10): () => T10;\n    pipe<V0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(\n      fn0: (x0: V0) => T1,\n      fn1: (x: T1) => T2,\n      fn2: (x: T2) => T3,\n      fn3: (x: T3) => T4,\n      fn4: (x: T4) => T5,\n      fn5: (x: T5) => T6,\n      fn6: (x: T6) => T7,\n      fn7: (x: T7) => T8,\n      fn8: (x: T8) => T9,\n      fn9: (x: T9) => T10): (x0: V0) => T10;\n    pipe<V0, V1, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(\n      fn0: (x0: V0, x1: V1) => T1,\n      fn1: (x: T1) => T2,\n      fn2: (x: T2) => T3,\n      fn3: (x: T3) => T4,\n      fn4: (x: T4) => T5,\n      fn5: (x: T5) => T6,\n      fn6: (x: T6) => T7,\n      fn7: (x: T7) => T8,\n      fn8: (x: T8) => T9,\n      fn9: (x: T9) => T10): (x0: V0, x1: V1) => T10;\n    pipe<V0, V1, V2, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(\n      fn0: (x0: V0, x1: V1, x2: V2) => T1,\n      fn1: (x: T1) => T2,\n      fn2: (x: T2) => T3,\n      fn3: (x: T3) => T4,\n      fn4: (x: T4) => T5,\n      fn5: (x: T5) => T6,\n      fn6: (x: T6) => T7,\n      fn7: (x: T7) => T8,\n      fn8: (x: T8) => T9,\n      fn9: (x: T9) => T10): (x0: V0, x1: V1, x2: V2) => T10;\n\n    /*\n     * Returns the left-to-right Kleisli composition of the provided functions, each of which must return a value of a type supported by chain.\n     * The typings currently support arrays only as return values.\n     * All functions need to be unary.\n     * R.pipeK(f, g, h) is equivalent to R.pipe(f, R.chain(g), R.chain(h)).\n     */\n    pipeK<V0, T1>(\n      fn0: (x0: V0) => T1[]): (x0: V0) => T1[];\n    pipeK<V0, T1, T2>(\n      fn0: (x0: V0) => T1[],\n      fn1: (x: T1) => T2[]): (x0: V0) => T2[];\n    pipeK<V0, T1, T2, T3>(\n      fn0: (x: V0) => T1[],\n      fn1: (x: T1) => T2[],\n      fn2: (x: T2) => T3[]): (x: V0) => T3[];\n    pipeK<V0, T1, T2, T3, T4>(\n      fn0: (x: V0) => T1[],\n      fn1: (x: T1) => T2[],\n      fn2: (x: T2) => T3[],\n      fn3: (x: T3) => T4[]): (x: V0) => T4[];\n    pipeK<V0, T1, T2, T3, T4, T5>(\n      fn0: (x: V0) => T1[],\n      fn1: (x: T1) => T2[],\n      fn2: (x: T2) => T3[],\n      fn3: (x: T3) => T4[],\n      fn4: (x: T4) => T5[]): (x: V0) => T5[];\n    pipeK<V0, T1, T2, T3, T4, T5, T6>(\n      fn0: (x: V0) => T1[],\n      fn1: (x: T1) => T2[],\n      fn2: (x: T2) => T3[],\n      fn3: (x: T3) => T4[],\n      fn4: (x: T4) => T5[],\n      fn5: (x: T5) => T6[]): (x: V0) => T6[];\n    pipeK<V0, T1, T2, T3, T4, T5, T6, T7>(\n      fn0: (x: V0) => T1[],\n      fn1: (x: T1) => T2[],\n      fn2: (x: T2) => T3[],\n      fn3: (x: T3) => T4[],\n      fn4: (x: T4) => T5[],\n      fn5: (x: T5) => T6[],\n      fn: (x: T6) => T7[]): (x: V0) => T7[];\n    pipeK<V0, T1, T2, T3, T4, T5, T6, T7, T8>(\n      fn0: (x: V0) => T1[],\n      fn1: (x: T1) => T2[],\n      fn2: (x: T2) => T3[],\n      fn3: (x: T3) => T4[],\n      fn4: (x: T4) => T5[],\n      fn5: (x: T5) => T6[],\n      fn6: (x: T6) => T7[],\n      fn: (x: T7) => T8[]): (x: V0) => T8[];\n    pipeK<V0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(\n      fn0: (x0: V0) => T1[],\n      fn1: (x: T1) => T2[],\n      fn2: (x: T2) => T3[],\n      fn3: (x: T3) => T4[],\n      fn4: (x: T4) => T5[],\n      fn5: (x: T5) => T6[],\n      fn6: (x: T6) => T7[],\n      fn7: (x: T7) => T8[],\n      fn8: (x: T8) => T9[]): (x0: V0) => T9[];\n    pipeK<V0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(\n      fn0: (x0: V0) => T1[],\n      fn1: (x: T1) => T2[],\n      fn2: (x: T2) => T3[],\n      fn3: (x: T3) => T4[],\n      fn4: (x: T4) => T5[],\n      fn5: (x: T5) => T6[],\n      fn6: (x: T6) => T7[],\n      fn7: (x: T7) => T8[],\n      fn8: (x: T8) => T9[],\n      fn9: (x: T9) => T10[]): (x0: V0) => T10[];\n\n    /*\n     * Performs left-to-right composition of one or more Promise-returning functions.\n     * All functions need to be unary.\n     */\n    pipeP<V0, T1>(\n      fn0: (x0: V0) => Promise<T1>): (x0: V0) => Promise<T1>;\n    pipeP<V0, T1, T2>(\n      fn0: (x0: V0) => Promise<T1>,\n      fn1: (x: T1) => Promise<T2>): (x0: V0) => Promise<T2>;\n    pipeP<V0, T1, T2, T3>(\n      fn0: (x: V0) => Promise<T1>,\n      fn1: (x: T1) => Promise<T2>,\n      fn2: (x: T2) => Promise<T3>): (x: V0) => Promise<T3>;\n    pipeP<V0, T1, T2, T3, T4>(\n      fn0: (x: V0) => Promise<T1>,\n      fn1: (x: T1) => Promise<T2>,\n      fn2: (x: T2) => Promise<T3>,\n      fn3: (x: T3) => Promise<T4>): (x: V0) => Promise<T4>;\n    pipeP<V0, T1, T2, T3, T4, T5>(\n      fn0: (x: V0) => Promise<T1>,\n      fn1: (x: T1) => Promise<T2>,\n      fn2: (x: T2) => Promise<T3>,\n      fn3: (x: T3) => Promise<T4>,\n      fn4: (x: T4) => Promise<T5>): (x: V0) => Promise<T5>;\n    pipeP<V0, T1, T2, T3, T4, T5, T6>(\n      fn0: (x: V0) => Promise<T1>,\n      fn1: (x: T1) => Promise<T2>,\n      fn2: (x: T2) => Promise<T3>,\n      fn3: (x: T3) => Promise<T4>,\n      fn4: (x: T4) => Promise<T5>,\n      fn5: (x: T5) => Promise<T6>): (x: V0) => Promise<T6>;\n    pipeP<V0, T1, T2, T3, T4, T5, T6, T7>(\n      fn0: (x: V0) => Promise<T1>,\n      fn1: (x: T1) => Promise<T2>,\n      fn2: (x: T2) => Promise<T3>,\n      fn3: (x: T3) => Promise<T4>,\n      fn4: (x: T4) => Promise<T5>,\n      fn5: (x: T5) => Promise<T6>,\n      fn: (x: T6) => Promise<T7>): (x: V0) => Promise<T7>;\n    pipeP<V0, T1, T2, T3, T4, T5, T6, T7, T8>(\n      fn0: (x: V0) => Promise<T1>,\n      fn1: (x: T1) => Promise<T2>,\n      fn2: (x: T2) => Promise<T3>,\n      fn3: (x: T3) => Promise<T4>,\n      fn4: (x: T4) => Promise<T5>,\n      fn5: (x: T5) => Promise<T6>,\n      fn6: (x: T6) => Promise<T7>,\n      fn: (x: T7) => Promise<T8>): (x: V0) => Promise<T8>;\n    pipeP<V0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(\n      fn0: (x0: V0) => Promise<T1>,\n      fn1: (x: T1) => Promise<T2>,\n      fn2: (x: T2) => Promise<T3>,\n      fn3: (x: T3) => Promise<T4>,\n      fn4: (x: T4) => Promise<T5>,\n      fn5: (x: T5) => Promise<T6>,\n      fn6: (x: T6) => Promise<T7>,\n      fn7: (x: T7) => Promise<T8>,\n      fn8: (x: T8) => Promise<T9>): (x0: V0) => Promise<T9>;\n    pipeP<V0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(\n      fn0: (x0: V0) => Promise<T1>,\n      fn1: (x: T1) => Promise<T2>,\n      fn2: (x: T2) => Promise<T3>,\n      fn3: (x: T3) => Promise<T4>,\n      fn4: (x: T4) => Promise<T5>,\n      fn5: (x: T5) => Promise<T6>,\n      fn6: (x: T6) => Promise<T7>,\n      fn7: (x: T7) => Promise<T8>,\n      fn8: (x: T8) => Promise<T9>,\n      fn9: (x: T9) => Promise<T10>): (x0: V0) => Promise<T10>;\n\n    /**\n     * Returns a new list by plucking the same named property off all objects in the list supplied.\n     */\n    pluck<K extends keyof T, T>(p: K, list: ReadonlyArray<T>): Array<T[K]>;\n    pluck<T>(p: number, list: ReadonlyArray<{ [k: number]: T }>): T[];\n    pluck<P extends string>(p: P): <T>(list: ReadonlyArray<Record<P, T>>) => T[];\n    pluck(p: number): <T>(list: ReadonlyArray<{ [k: number]: T }>) => T[];\n\n    /**\n     * Returns a new list with the given element at the front, followed by the contents of the\n     * list.\n     */\n    prepend<T>(el: T, list: ReadonlyArray<T>): T[];\n    prepend<T>(el: T): (list: ReadonlyArray<T>) => T[];\n\n    /**\n     * Multiplies together all the elements of a list.\n     */\n    product(list: ReadonlyArray<number>): number;\n\n    /**\n     * Reasonable analog to SQL select statement.\n     */\n    project<T, U>(props: ReadonlyArray<string>, objs: ReadonlyArray<T>): U[];\n    project<T, U>(props: ReadonlyArray<string>): (objs: ReadonlyArray<T>) => U[];\n\n    /**\n     * Returns a function that when supplied an object returns the indicated property of that object, if it exists.\n     */\n    prop<T>(__: Placeholder, obj: T): <P extends keyof T>(p: P) => T[P];\n    prop<P extends keyof T, T>(p: P, obj: T): T[P];\n    prop<P extends string>(p: P): <T>(obj: Record<P, T>) => T;\n    prop<P extends string, T>(p: P): (obj: Record<P, T>) => T;\n\n    /**\n     * Determines whether the given property of an object has a specific\n     * value according to strict equality (===).  Most likely used to\n     * filter a list.\n     */\n    propEq<T>(name: string | number, val: T, obj: any): boolean;\n    propEq<T>(name: string | number, val: T): (obj: any) => boolean;\n    propEq(name: string | number): {\n      <T>(val: T, obj: any): boolean;\n      <T>(val: T): (obj: any) => boolean;\n    };\n\n    /**\n     * Returns true if the specified object property is of the given type; false otherwise.\n     */\n    propIs(type: any, name: string, obj: any): boolean;\n    propIs(type: any, name: string): (obj: any) => boolean;\n    propIs(type: any): {\n      (name: string, obj: any): boolean;\n      (name: string): (obj: any) => boolean;\n    };\n\n    /**\n     * If the given, non-null object has an own property with the specified name, returns the value of that property.\n     * Otherwise returns the provided default value.\n     */\n    propOr<T, U, V>(val: T, p: string, obj: U): V;\n    propOr<T>(val: T, p: string): <U, V>(obj: U) => V;\n    propOr<T>(val: T): <U, V>(p: string, obj: U) => V;\n\n    /**\n     * Returns the value at the specified property.\n     * The only difference from prop is the parameter order.\n     * Note: TS1.9 # replace any by dictionary\n     */\n    props<P extends string, T>(ps: ReadonlyArray<P>, obj: Record<P, T>): T[];\n    props<P extends string>(ps: ReadonlyArray<P>): <T>(obj: Record<P, T>) => T[];\n    props<P extends string, T>(ps: ReadonlyArray<P>): (obj: Record<P, T>) => T[];\n\n    /**\n     * Returns true if the specified object property satisfies the given predicate; false otherwise.\n     */\n    propSatisfies<T, U>(pred: (val: T) => boolean, name: string, obj: U): boolean;\n    propSatisfies<T, U>(pred: (val: T) => boolean, name: string): (obj: U) => boolean;\n    propSatisfies<T, U>(pred: (val: T) => boolean): Curry.Curry<(a: string, b: U) => boolean>;\n\n    /**\n     * Returns a list of numbers from from (inclusive) to to\n     * (exclusive). In mathematical terms, range(a, b) is equivalent to\n     * the half-open interval [a, b).\n     */\n    range(from: number, to: number): number[];\n    range(from: number): (to: number) => number[];\n\n    /**\n     * Returns a single item by iterating through the list, successively calling the iterator\n     * function and passing it an accumulator value and the current value from the array, and\n     * then passing the result to the next call.\n     */\n    reduce<T, TResult>(fn: (acc: TResult, elem: T) => TResult | Reduced<TResult>, acc: TResult, list: ReadonlyArray<T>): TResult;\n    reduce<T, TResult>(fn: (acc: TResult, elem: T) => TResult | Reduced<TResult>): (acc: TResult, list: ReadonlyArray<T>) => TResult;\n    reduce<T, TResult>(fn: (acc: TResult, elem: T) => TResult | Reduced<TResult>, acc: TResult): (list: ReadonlyArray<T>) => TResult;\n\n    /**\n     * Groups the elements of the list according to the result of calling the String-returning function keyFn on each\n     * element and reduces the elements of each group to a single value via the reducer function valueFn.\n     */\n    reduceBy<T, TResult>(valueFn: (acc: TResult, elem: T) => TResult, acc: TResult, keyFn: (elem: T) => string, list: ReadonlyArray<T>): { [index: string]: TResult };\n    reduceBy<T, TResult>(valueFn: (acc: TResult, elem: T) => TResult, acc: TResult, keyFn: (elem: T) => string): (list: ReadonlyArray<T>) => { [index: string]: TResult };\n    reduceBy<T, TResult>(valueFn: (acc: TResult, elem: T) => TResult, acc: TResult): Curry.Curry<(a: (elem: T) => string, b: ReadonlyArray<T>) => { [index: string]: TResult }>;\n    reduceBy<T, TResult>(valueFn: (acc: TResult, elem: T) => TResult): Curry.Curry<(a: TResult, b: (elem: T) => string, c: ReadonlyArray<T>) => { [index: string]: TResult }>;\n\n    /**\n     * Returns a value wrapped to indicate that it is the final value of the reduce and\n     * transduce functions. The returned value should be considered a black box: the internal\n     * structure is not guaranteed to be stable.\n     */\n    reduced<T>(elem: T): Reduced<T>;\n\n    /**\n     * Returns a single item by iterating through the list, successively calling the iterator\n     * function and passing it an accumulator value and the current value from the array, and\n     * then passing the result to the next call.\n     */\n    reduceRight<T, TResult>(fn: (elem: T, acc: TResult) => TResult, acc: TResult, list: ReadonlyArray<T>): TResult;\n    reduceRight<T, TResult>(fn: (elem: T, acc: TResult) => TResult): (acc: TResult, list: ReadonlyArray<T>) => TResult;\n    reduceRight<T, TResult>(fn: (elem: T, acc: TResult) => TResult, acc: TResult): (list: ReadonlyArray<T>) => TResult;\n\n    /**\n     * Like reduce, reduceWhile returns a single item by iterating through the list, successively\n     * calling the iterator function. reduceWhile also takes a predicate that is evaluated before\n     * each step. If the predicate returns false, it \"short-circuits\" the iteration and returns\n     * the current value of the accumulator.\n     */\n    reduceWhile<T, TResult>(predicate: (acc: TResult, elem: T) => boolean, fn: (acc: TResult, elem: T) => TResult, acc: TResult, list: ReadonlyArray<T>): TResult;\n    reduceWhile<T, TResult>(predicate: (acc: TResult, elem: T) => boolean, fn: (acc: TResult, elem: T) => TResult, acc: TResult): (list: ReadonlyArray<T>) => TResult;\n    reduceWhile<T, TResult>(predicate: (acc: TResult, elem: T) => boolean, fn: (acc: TResult, elem: T) => TResult): Curry.Curry<(a: TResult, b: ReadonlyArray<T>) => TResult>;\n    reduceWhile<T, TResult>(predicate: (acc: TResult, elem: T) => boolean): Curry.Curry<(a: (acc: TResult, elem: T) => TResult, b: TResult, c: ReadonlyArray<T>) => TResult>;\n\n    /**\n     * Similar to filter, except that it keeps only values for which the given predicate\n     * function returns falsy.\n     */\n    reject: Filter;\n\n    /**\n     * Removes the sub-list of list starting at index start and containing count elements.\n     */\n    remove<T>(start: number, count: number, list: ReadonlyArray<T>): T[];\n    remove<T>(start: number): (count: number, list: ReadonlyArray<T>) => T[];\n    remove<T>(start: number, count: number): (list: ReadonlyArray<T>) => T[];\n\n    /**\n     * Returns a fixed list of size n containing a specified identical value.\n     */\n    repeat<T>(a: T, n: number): T[];\n    repeat<T>(a: T): (n: number) => T[];\n\n    /**\n     * Replace a substring or regex match in a string with a replacement.\n     */\n    replace(pattern: RegExp | string, replacement: string | ((match: string, ...args: any[]) => string), str: string): string;\n    replace(pattern: RegExp | string, replacement: string | ((match: string, ...args: any[]) => string)): (str: string) => string;\n    replace(pattern: RegExp | string): (replacement: string | ((match: string, ...args: any[]) => string)) => (str: string) => string;\n\n    /**\n     * Returns a new list with the same elements as the original list, just in the reverse order.\n     */\n    reverse<T>(list: ReadonlyArray<T>): T[];\n    /**\n     * Returns a new string with the characters in reverse order.\n     */\n    reverse(str: string): string;\n\n    /**\n     * Scan is similar to reduce, but returns a list of successively reduced values from the left.\n     */\n    scan<T, TResult>(fn: (acc: TResult, elem: T) => any, acc: TResult, list: ReadonlyArray<T>): TResult[];\n    scan<T, TResult>(fn: (acc: TResult, elem: T) => any, acc: TResult): (list: ReadonlyArray<T>) => TResult[];\n    scan<T, TResult>(fn: (acc: TResult, elem: T) => any): (acc: TResult, list: ReadonlyArray<T>) => TResult[];\n\n    /**\n     * Returns the result of \"setting\" the portion of the given data structure focused by the given lens to the\n     * given value.\n     */\n    set<T, U>(lens: Lens, a: U, obj: T): T;\n    set<U>(lens: Lens, a: U): <T>(obj: T) => T;\n    set(lens: Lens): <T, U>(a: U, obj: T) => T;\n\n    /**\n     * Returns the elements from xs starting at a and ending at b - 1.\n     */\n    slice(a: number, b: number, list: string): string;\n    slice<T>(a: number, b: number, list: ReadonlyArray<T>): T[];\n    slice(a: number, b: number): {\n      (list: string): string;\n      <T>(list: ReadonlyArray<T>): T[];\n    };\n    slice(a: number): {\n      (b: number, list: string): string;\n      <T>(b: number, list: ReadonlyArray<T>): T[];\n    };\n\n    /**\n     * Returns a copy of the list, sorted according to the comparator function, which should accept two values at a\n     * time and return a negative number if the first value is smaller, a positive number if it's larger, and zero\n     * if they are equal.\n     */\n    sort<T>(fn: (a: T, b: T) => number, list: ReadonlyArray<T>): T[];\n    sort<T>(fn: (a: T, b: T) => number): (list: ReadonlyArray<T>) => T[];\n\n    /**\n     * Sorts the list according to a key generated by the supplied function.\n     */\n    sortBy<T>(fn: (a: T) => Ord, list: ReadonlyArray<T>): T[];\n    sortBy(fn: (a: any) => Ord): <T>(list: ReadonlyArray<T>) => T[];\n\n    /**\n     * Sorts a list according to a list of comparators.\n     */\n    sortWith<T>(fns: ReadonlyArray<((a: T, b: T) => number)>, list: ReadonlyArray<T>): T[];\n    sortWith<T>(fns: ReadonlyArray<((a: T, b: T) => number)>): (list: ReadonlyArray<T>) => T[];\n\n    /**\n     * Splits a string into an array of strings based on the given\n     * separator.\n     */\n    split(sep: string | RegExp): (str: string) => string[];\n    split(sep: string | RegExp, str: string): string[];\n\n    /**\n     * Splits a given list or string at a given index.\n     */\n    splitAt<T>(index: number, list: ReadonlyArray<T>): [T[], T[]];\n    splitAt(index: number, list: string): [string, string];\n    splitAt(index: number): {\n      <T>(list: ReadonlyArray<T>): [T[], T[]];\n      (list: string): [string, string];\n    };\n\n    /**\n     * Splits a collection into slices of the specified length.\n     */\n    splitEvery<T>(a: number, list: ReadonlyArray<T>): T[][];\n    splitEvery(a: number, list: string): string[];\n    splitEvery(a: number): {\n      (list: string): string[];\n      <T>(list: ReadonlyArray<T>): T[][];\n    };\n\n    /**\n     * Takes a list and a predicate and returns a pair of lists with the following properties:\n     * - the result of concatenating the two output lists is equivalent to the input list;\n     * - none of the elements of the first output list satisfies the predicate; and\n     * - if the second output list is non-empty, its first element satisfies the predicate.\n     */\n    splitWhen<T, U>(pred: (val: T) => boolean, list: ReadonlyArray<U>): U[][];\n    splitWhen<T>(pred: (val: T) => boolean): <U>(list: ReadonlyArray<U>) => U[][];\n\n    /**\n     * Checks if a list starts with the provided values\n     */\n    startsWith(a: string, list: string): boolean;\n    startsWith(a: string): (list: string) => boolean;\n    startsWith<T>(a: T | ReadonlyArray<T>, list: ReadonlyArray<T>): boolean;\n    startsWith<T>(a: T | ReadonlyArray<T>): (list: ReadonlyArray<T>) => boolean;\n\n    /**\n     * Subtracts two numbers. Equivalent to a - b but curried.\n     */\n    subtract(__: Placeholder, b: number): (a: number) => number;\n    subtract(__: Placeholder): (b: number, a: number) => number;\n    subtract(a: number, b: number): number;\n    subtract(a: number): (b: number) => number;\n\n    /**\n     * Adds together all the elements of a list.\n     */\n    sum(list: ReadonlyArray<number>): number;\n\n    /**\n     * Finds the set (i.e. no duplicates) of all elements contained in the first or second list, but not both.\n     */\n    symmetricDifference<T>(list1: ReadonlyArray<T>, list2: ReadonlyArray<T>): T[];\n    symmetricDifference<T>(list: ReadonlyArray<T>): <T>(list: ReadonlyArray<T>) => T[];\n\n    /**\n     * Finds the set (i.e. no duplicates) of all elements contained in the first or second list, but not both.\n     * Duplication is determined according to the value returned by applying the supplied predicate to two list elements.\n     */\n    symmetricDifferenceWith<T>(pred: (a: T, b: T) => boolean, list1: ReadonlyArray<T>, list2: ReadonlyArray<T>): T[];\n    symmetricDifferenceWith<T>(pred: (a: T, b: T) => boolean): Curry.Curry<(a: ReadonlyArray<T>, b: ReadonlyArray<T>) => T[]>;\n\n    /**\n     * A function that always returns true. Any passed in parameters are ignored.\n     */\n    T(): boolean;\n\n    /**\n     * Returns all but the first element of a list or string.\n     */\n    tail<T>(list: ReadonlyArray<T>): T[];\n    tail(list: string): string;\n\n    /**\n     * Returns a new list containing the first n elements of the given list.  If\n     * n > * list.length, returns a list of list.length elements.\n     */\n    take<T>(n: number, xs: ReadonlyArray<T>): T[];\n    take(n: number, xs: string): string;\n    take<T>(n: number): {\n      (xs: string): string;\n      (xs: ReadonlyArray<T>): T[];\n    };\n\n    /**\n     * Returns a new list containing the last n elements of the given list. If n > list.length,\n     * returns a list of list.length elements.\n     */\n    takeLast<T>(n: number, xs: ReadonlyArray<T>): T[];\n    takeLast(n: number, xs: string): string;\n    takeLast(n: number): {\n      <T>(xs: ReadonlyArray<T>): T[];\n      (xs: string): string;\n    };\n\n    /**\n     * Returns a new list containing the last n elements of a given list, passing each value\n     * to the supplied predicate function, and terminating when the predicate function returns\n     * false. Excludes the element that caused the predicate function to fail. The predicate\n     * function is passed one argument: (value).\n     */\n    takeLastWhile<T>(pred: (a: T) => boolean, list: ReadonlyArray<T>): T[];\n    takeLastWhile<T>(pred: (a: T) => boolean): <T>(list: ReadonlyArray<T>) => T[];\n\n    /**\n     * Returns a new list containing the first n elements of a given list, passing each value\n     * to the supplied predicate function, and terminating when the predicate function returns\n     * false.\n     */\n    takeWhile<T>(fn: (x: T) => boolean, list: ReadonlyArray<T>): T[];\n    takeWhile<T>(fn: (x: T) => boolean): (list: ReadonlyArray<T>) => T[];\n\n    /**\n     * The function to call with x. The return value of fn will be thrown away.\n     */\n    tap<T>(fn: (a: T) => any, value: T): T;\n    tap<T>(fn: (a: T) => any): (value: T) => T;\n\n    /**\n     * Determines whether a given string matches a given regular expression.\n     */\n    test(regexp: RegExp, str: string): boolean;\n    test(regexp: RegExp): (str: string) => boolean;\n\n    /**\n     * Calls an input function n times, returning an array containing the results of those\n     * function calls.\n     */\n    times<T>(fn: (i: number) => T, n: number): T[];\n    times<T>(fn: (i: number) => T): (n: number) => T[];\n\n    /**\n     * The lower case version of a string.\n     */\n    toLower(str: string): string;\n\n    /**\n     * Converts an object into an array of key, value arrays.\n     * Only the object's own properties are used.\n     * Note that the order of the output array is not guaranteed to be\n     * consistent across different JS platforms.\n     */\n    toPairs<S>(obj: { [k: string]: S } | { [k: number]: S }): Array<[string, S]>;\n\n    /**\n     * Converts an object into an array of key, value arrays.\n     * The object's own properties and prototype properties are used.\n     * Note that the order of the output array is not guaranteed to be\n     * consistent across different JS platforms.\n     */\n    toPairsIn<S>(obj: { [k: string]: S } | { [k: number]: S }): Array<[string, S]>;\n\n    /**\n     * Returns the string representation of the given value. eval'ing the output should\n     * result in a value equivalent to the input value. Many of the built-in toString\n     * methods do not satisfy this requirement.\n     *\n     * If the given value is an [object Object] with a toString method other than\n     * Object.prototype.toString, this method is invoked with no arguments to produce the\n     * return value. This means user-defined constructor functions can provide a suitable\n     * toString method.\n     */\n    toString<T>(val: T): string;\n\n    /**\n     * The upper case version of a string.\n     */\n    toUpper(str: string): string;\n\n    /**\n     * Initializes a transducer using supplied iterator function. Returns a single item by iterating through the\n     * list, successively calling the transformed iterator function and passing it an accumulator value and the\n     * current value from the array, and then passing the result to the next call.\n     */\n    transduce<T, U>(xf: (arg: T[]) => ReadonlyArray<T>, fn: (acc: U[], val: U) => ReadonlyArray<U>, acc: ReadonlyArray<T>, list: ReadonlyArray<T>): U;\n    transduce<T, U>(xf: (arg: T[]) => ReadonlyArray<T>): (fn: (acc: U[], val: U) => ReadonlyArray<U>, acc: ReadonlyArray<T>, list: ReadonlyArray<T>) => U;\n    transduce<T, U>(xf: (arg: T[]) => ReadonlyArray<T>, fn: (acc: U[], val: U) => ReadonlyArray<U>): (acc: ReadonlyArray<T>, list: ReadonlyArray<T>) => U;\n    transduce<T, U>(xf: (arg: T[]) => ReadonlyArray<T>, fn: (acc: U[], val: U) => ReadonlyArray<U>, acc: ReadonlyArray<T>): (list: ReadonlyArray<T>) => U;\n\n    /**\n     * Transposes the rows and columns of a 2D list. When passed a list of n lists of length x, returns a list of x lists of length n.\n     */\n    transpose<T>(list: ReadonlyArray<T[]>): T[][];\n\n    /**\n     * Maps an Applicative-returning function over a Traversable, then uses\n     * sequence to transform the resulting Traversable of Applicative into\n     * an Applicative of Traversable.\n     */\n    traverse<T, U, A>(of: (a: U[]) => A, fn: (t: T) => U, list: ReadonlyArray<T>): A;\n    traverse<T, U, A>(of: (a: U[]) => A, fn: (t: T) => U): (list: ReadonlyArray<T>) => A;\n    traverse<T, U, A>(of: (a: U[]) => A): (fn: (t: T) => U, list: ReadonlyArray<T>) => A;\n\n    /**\n     * Removes (strips) whitespace from both ends of the string.\n     */\n    trim(str: string): string;\n\n    /**\n     * tryCatch takes two functions, a tryer and a catcher. The returned function evaluates the tryer; if it does\n     * not throw, it simply returns the result. If the tryer does throw, the returned function evaluates the catcher\n     * function and returns its result. Note that for effective composition with this function, both the tryer and\n     * catcher functions must return the same type of results.\n     */\n    tryCatch<T>(tryer: (...args: any[]) => T, catcher: (...args: any[]) => T): (...args: any[]) => T;\n\n    /**\n     * Gives a single-word string description of the (native) type of a value, returning such answers as 'Object',\n     * 'Number', 'Array', or 'Null'. Does not attempt to distinguish user Object types any further, reporting them\n     * all as 'Object'.\n     */\n    type(val: any): 'Object' | 'Number' | 'Boolean' | 'String' | 'Null' | 'Array' | 'RegExp' | 'Function' | 'Undefined';\n\n    /**\n     * Takes a function fn, which takes a single array argument, and returns a function which:\n     * - takes any number of positional arguments;\n     * - passes these arguments to fn as an array; and\n     * - returns the result.\n     * In other words, R.unapply derives a variadic function from a function which takes an array.\n     * R.unapply is the inverse of R.apply.\n     */\n    unapply<T>(fn: (args: any[]) => T): (...args: any[]) => T;\n\n    /**\n     * Wraps a function of any arity (including nullary) in a function that accepts exactly 1 parameter.\n     * Any extraneous parameters will not be passed to the supplied function.\n     */\n    unary<T>(fn: (a: T, ...args: any[]) => any): (a: T) => any;\n\n    /**\n     * Returns a function of arity n from a (manually) curried function.\n     */\n    uncurryN<T>(len: number, fn: (a: any) => any): (...a: any[]) => T;\n\n    /**\n     * Builds a list from a seed value. Accepts an iterator function, which returns either false\n     * to stop iteration or an array of length 2 containing the value to add to the resulting\n     * list and the seed to be used in the next call to the iterator function.\n     */\n    unfold<T, TResult>(fn: (seed: T) => [TResult, T] | false, seed: T): TResult[];\n    unfold<T, TResult>(fn: (seed: T) => [TResult, T] | false): (seed: T) => TResult[];\n\n    /**\n     * Combines two lists into a set (i.e. no duplicates) composed of the\n     * elements of each list.\n     */\n    union<T>(as: ReadonlyArray<T>, bs: ReadonlyArray<T>): T[];\n    union<T>(as: ReadonlyArray<T>): (bs: ReadonlyArray<T>) => T[];\n\n    /**\n     * Combines two lists into a set (i.e. no duplicates) composed of the elements of each list.  Duplication is\n     * determined according to the value returned by applying the supplied predicate to two list elements.\n     */\n    unionWith<T>(pred: (a: T, b: T) => boolean, list1: ReadonlyArray<T>, list2: ReadonlyArray<T>): T[];\n    unionWith<T>(pred: (a: T, b: T) => boolean): Curry.Curry<(a: ReadonlyArray<T>, b: ReadonlyArray<T>) => T[]>;\n\n    /**\n     * Returns a new list containing only one copy of each element in the original list.\n     */\n    uniq<T>(list: ReadonlyArray<T>): T[];\n\n    /**\n     * Returns a new list containing only one copy of each element in the original list,\n     * based upon the value returned by applying the supplied function to each list element.\n     * Prefers the first item if the supplied function produces the same value on two items.\n     * R.equals is used for comparison.\n     */\n    uniqBy<T, U>(fn: (a: T) => U, list: ReadonlyArray<T>): T[];\n    uniqBy<T, U>(fn: (a: T) => U): (list: ReadonlyArray<T>) => T[];\n\n    /**\n     * Returns a new list containing only one copy of each element in the original list, based upon the value\n     * returned by applying the supplied predicate to two list elements.\n     */\n    uniqWith<T, U>(pred: (x: T, y: T) => boolean, list: ReadonlyArray<T>): T[];\n    uniqWith<T, U>(pred: (x: T, y: T) => boolean): (list: ReadonlyArray<T>) => T[];\n\n    /**\n     * Tests the final argument by passing it to the given predicate function. If the predicate is not satisfied,\n     * the function will return the result of calling the whenFalseFn function with the same argument. If the\n     * predicate is satisfied, the argument is returned as is.\n     */\n    unless<T, U>(pred: (a: T) => boolean, whenFalseFn: (a: T) => U, obj: T): U;\n    unless<T, U>(pred: (a: T) => boolean, whenFalseFn: (a: T) => U): (obj: T) => U;\n\n    /**\n     * Returns a new list by pulling every item at the first level of nesting out, and putting\n     * them in a new array.\n     */\n    unnest<T>(x: ReadonlyArray<T[]> | ReadonlyArray<ReadonlyArray<T>> | ReadonlyArray<T>): T[];\n\n    /**\n     * Takes a predicate, a transformation function, and an initial value, and returns a value of the same type as\n     * the initial value. It does so by applying the transformation until the predicate is satisfied, at which point\n     * it returns the satisfactory value.\n     */\n    until<T, U>(pred: (val: T) => boolean, fn: (val: T) => U, init: U): U;\n    until<T, U>(pred: (val: T) => boolean, fn: (val: T) => U): (init: U) => U;\n\n    /**\n     * Returns a new copy of the array with the element at the provided index replaced with the given value.\n     */\n    update<T>(index: number, value: T, list: ReadonlyArray<T>): T[];\n    update<T>(index: number, value: T): (list: ReadonlyArray<T>) => T[];\n\n    /**\n     * Accepts a function fn and a list of transformer functions and returns a new curried function.\n     * When the new function is invoked, it calls the function fn with parameters consisting of the\n     * result of calling each supplied handler on successive arguments to the new function.\n     *\n     * If more arguments are passed to the returned function than transformer functions, those arguments\n     * are passed directly to fn as additional parameters. If you expect additional arguments that don't\n     * need to be transformed, although you can ignore them, it's best to pass an identity function so\n     * that the new function reports the correct arity.\n     */\n    useWith(fn: ((...a: any[]) => any), transformers: Array<((...a: any[]) => any)>): (...a: any[]) => any;\n\n    /**\n     * Returns a list of all the enumerable own properties of the supplied object.\n     * Note that the order of the output array is not guaranteed across\n     * different JS platforms.\n     */\n    values<T extends object, K extends keyof T>(obj: T): Array<T[K]>;\n\n    /**\n     * Returns a list of all the properties, including prototype properties, of the supplied\n     * object. Note that the order of the output array is not guaranteed to be consistent across different JS platforms.\n     */\n    valuesIn<T>(obj: any): T[];\n\n    /**\n     * Returns a \"view\" of the given data structure, determined by the given lens. The lens's focus determines which\n     * portion of the data structure is visible.\n     */\n    view<T, U>(lens: Lens): (obj: T) => U;\n    view<T, U>(lens: Lens, obj: T): U;\n\n    /**\n     * Tests the final argument by passing it to the given predicate function. If the predicate is satisfied, the function\n     * will return the result of calling the whenTrueFn function with the same argument. If the predicate is not satisfied,\n     * the argument is returned as is.\n     */\n    when<T, U>(pred: (a: T) => boolean, whenTrueFn: (a: T) => U, obj: T): U;\n    when<T, U>(pred: (a: T) => boolean, whenTrueFn: (a: T) => U): (obj: T) => U;\n\n    /**\n     * Takes a spec object and a test object and returns true if the test satisfies the spec.\n     * Any property on the spec that is not a function is interpreted as an equality\n     * relation.\n     *\n     * If the spec has a property mapped to a function, then where evaluates the function, passing in\n     * the test object's value for the property in question, as well as the whole test object.\n     *\n     * where is well suited to declarativley expressing constraints for other functions, e.g.,\n     * filter, find, pickWith, etc.\n     */\n    where<T, U>(spec: T, testObj: U): boolean;\n    where<T>(spec: T): <U>(testObj: U) => boolean;\n    where<ObjFunc2, U>(spec: ObjFunc2, testObj: U): boolean;\n    where<ObjFunc2>(spec: ObjFunc2): <U>(testObj: U) => boolean;\n\n    /**\n     * Takes a spec object and a test object; returns true if the test satisfies the spec,\n     * false otherwise. An object satisfies the spec if, for each of the spec's own properties,\n     * accessing that property of the object gives the same value (in R.eq terms) as accessing\n     * that property of the spec.\n     */\n    whereEq<T, U>(spec: T, obj: U): boolean;\n    whereEq<T>(spec: T): <U>(obj: U) => boolean;\n\n    /**\n     * Returns a new list without values in the first argument. R.equals is used to determine equality.\n     * Acts as a transducer if a transformer is given in list position.\n     */\n    without<T>(list1: ReadonlyArray<T>, list2: ReadonlyArray<T>): T[];\n    without<T>(list1: ReadonlyArray<T>): (list2: ReadonlyArray<T>) => T[];\n\n    /**\n     * Wrap a function inside another to allow you to make adjustments to the parameters, or do other processing\n     * either before the internal function is called or with its results.\n     */\n    wrap(fn: (...a: any[]) => any, wrapper: (...a: any[]) => any): (...a: any[]) => any;\n\n    /**\n     * Creates a new list out of the two supplied by creating each possible pair from the lists.\n     */\n    xprod<K, V>(as: ReadonlyArray<K>, bs: ReadonlyArray<V>): Array<KeyValuePair<K, V>>;\n    xprod<K>(as: ReadonlyArray<K>): <V>(bs: ReadonlyArray<V>) => Array<KeyValuePair<K, V>>;\n\n    /**\n     * Creates a new list out of the two supplied by pairing up equally-positioned items from\n     * both lists. Note: zip is equivalent to zipWith(function(a, b) { return [a, b] }).\n     */\n    zip<K, V>(list1: ReadonlyArray<K>, list2: ReadonlyArray<V>): Array<KeyValuePair<K, V>>;\n    zip<K>(list1: ReadonlyArray<K>): <V>(list2: ReadonlyArray<V>) => Array<KeyValuePair<K, V>>;\n\n    /**\n     * Creates a new object out of a list of keys and a list of values.\n     */\n    // TODO: Dictionary<T> as a return value is to specific, any seems to loose\n    zipObj<T>(keys: ReadonlyArray<string>, values: ReadonlyArray<T>): { [index: string]: T };\n    zipObj(keys: ReadonlyArray<string>): <T>(values: ReadonlyArray<T>) => { [index: string]: T };\n\n    /**\n     * Creates a new list out of the two supplied by applying the function to each\n     * equally-positioned pair in the lists.\n     */\n    zipWith<T, U, TResult>(fn: (x: T, y: U) => TResult, list1: ReadonlyArray<T>, list2: ReadonlyArray<U>): TResult[];\n    zipWith<T, U, TResult>(fn: (x: T, y: U) => TResult, list1: ReadonlyArray<T>): (list2: ReadonlyArray<U>) => TResult[];\n    zipWith<T, U, TResult>(fn: (x: T, y: U) => TResult): (list1: ReadonlyArray<T>, list2: ReadonlyArray<U>) => TResult[];\n  }\n}\n\nexport = R;\nexport as namespace R;\n`","export const content =\n`\nimport {Item} from 'models';\n\nexport interface Event {\n    input: Item[]\n }\n\nexport interface Context {\n   \n}\n`","import React,{Component} from 'react';\nimport MonacoEditor from 'react-monaco-editor'\nimport * as monaco from 'monaco-editor/esm/vs/editor/editor.api';\nimport {Uri} from 'monaco-editor/esm/vs/editor/editor.api';\n\nimport {files} from './typings';\n\nconst code =\n`\n//--------------------------\n// Contents of \"models\"\n//--------------------------\n//\n// export interface Item {\n//    id: String;\n//    name: String;\n//    value: String;\n// }\n//\n// export interface Result {\n//    id: String;\n//    name: String;\n//    value: String;\n// }\n\n//--------------------------\n// Contents of \"lambda\"\n//--------------------------\n//\n// import {Item} from 'models';\n//\n// export interface Event {\n//     input: Item[]\n// }\n//\n// export interface Context {\n//  \n// }\n\n\nimport {Event, Context} from \"lambda\";\nimport {Item, Result} from \"models\"\nimport * as R from \"ramda\";\n \nexport const lambda = async (event:Event, context:Context): Promise<Result[]> => {\n    \n    const result:Result[] = R.map((input:Item) => ({\n        id: input.id,\n        name: input.name,\n        value: input.value\n    }),event.input);\n    \n    return result;\n}\n\n\n\n\n`\nexport class AdvancedTypescriptEditor extends Component {\n\n\n    constructor(props){\n        super(props);\n        this.state = {\n            code\n        }\n    }\n\n    onChange(newValue, e) {\n        // console.log('onChange', newValue, e);\n    }\n\n    editorWillMount(monaco) {\n\n        // validation settings\n        monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({\n            noSemanticValidation: false,\n            noSyntaxValidation: false\n        });\n\n        // compiler options\n        monaco.languages.typescript.typescriptDefaults.setCompilerOptions({\n            target: monaco.languages.typescript.ScriptTarget.ES6,\n            allowNonTsExtensions: true\n        });\n\n        for (const fileName in files) {\n            const fakePath = `file:///node_modules/@types/${fileName}`;\n\n            monaco.languages.typescript.typescriptDefaults.addExtraLib(\n                files[fileName],\n                fakePath\n            );\n        }\n\n\n    }\n\n\n\n    editorDidMount(editor, monaco) {\n        editor.focus();\n    }\n\n    render() {\n        const options = {\n            selectOnLineNumbers: true,\n            model: monaco.editor.getModel(Uri.parse(\"file:///main.tsx\"))\n                ||\n                monaco.editor.createModel(code, \"typescript\", monaco.Uri.parse(\"file:///main.tsx\"))\n        }\n        return (\n            <MonacoEditor\n                width=\"800\"\n                height=\"800\"\n                language=\"typescript\"\n                theme=\"vs-dark\"\n                defaultValue=''\n                value={this.state.code}\n                onChange={this.onChange}\n                editorWillMount={this.editorWillMount}\n                editorDidMount={this.editorDidMount}\n                options={options}\n            />\n        )\n    }\n}","import React, {Component} from 'react';\nimport './App.css';\nimport {SimpleTypescriptEditor} from \"./components/SimpleTypescriptEditor\";\nimport {AdvancedTypescriptEditor} from \"./components/AdvancedTypescriptEditor\";\n\nclass App extends Component {\n    render() {\n        return (\n            <div style={{padding: 20}}>\n                <table width=\"100%\">\n                    <tr>\n                        <td>\n                            <h1><a id=\"Simple\">Simple TypeScript Editor</a></h1>\n                            <SimpleTypescriptEditor/>\n                        </td>\n                        <td>\n                            <h1><a id=\"Advanced\">Advanced TypeScript Editor</a></h1>\n                            <AdvancedTypescriptEditor/>\n                        </td>\n                    </tr>\n                </table>\n            </div>\n        );\n    }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}